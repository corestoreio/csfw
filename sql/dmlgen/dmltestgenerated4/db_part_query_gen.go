// Code generated by codegen. DO NOT EDIT.
// Generated by sql/dmlgen. DO NOT EDIT.
package dmltestgenerated2

import (
	"context"
	"time"

	"github.com/corestoreio/errors"
	"github.com/corestoreio/pkg/sql/ddl"
	"github.com/corestoreio/pkg/sql/dml"
	"github.com/corestoreio/pkg/storage/null"
)

const (
	TableNameCoreConfiguration         = "core_configuration"
	TableNameSalesOrderStatusState     = "sales_order_status_state"
	TableNameViewCustomerAutoIncrement = "view_customer_auto_increment"
)

// DBMOption provides various options to the DBM object.
type DBMOption struct {
	TableOptions                       []ddl.TableOption
	InitSelectFn                       func(*dml.Select) *dml.Select
	InitInsertFn                       func(*dml.Insert) *dml.Insert
	eventCoreConfigurationFunc         [dml.EventFlagMax][]func(context.Context, *CoreConfiguration) error
	eventSalesOrderStatusStateFunc     [dml.EventFlagMax][]func(context.Context, *SalesOrderStatusState) error
	eventViewCustomerAutoIncrementFunc [dml.EventFlagMax][]func(context.Context, *ViewCustomerAutoIncrement) error
}

// AddEventCoreConfiguration adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCoreConfiguration(event dml.EventFlag, fn func(context.Context, *CoreConfiguration) error) *DBMOption {
	o.eventCoreConfigurationFunc[event] = append(o.eventCoreConfigurationFunc[event], fn)
	return o
}

// AddEventSalesOrderStatusState adds a specific defined event call back to the
// DBM. It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventSalesOrderStatusState(event dml.EventFlag, fn func(context.Context, *SalesOrderStatusState) error) *DBMOption {
	o.eventSalesOrderStatusStateFunc[event] = append(o.eventSalesOrderStatusStateFunc[event], fn)
	return o
}

// AddEventViewCustomerAutoIncrement adds a specific defined event call back to
// the DBM. It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventViewCustomerAutoIncrement(event dml.EventFlag, fn func(context.Context, *ViewCustomerAutoIncrement) error) *DBMOption {
	o.eventViewCustomerAutoIncrementFunc[event] = append(o.eventViewCustomerAutoIncrementFunc[event], fn)
	return o
}

// DBM defines the DataBaseManagement object for the tables  core_configuration,
// sales_order_status_state, view_customer_auto_increment
type DBM struct {
	*ddl.Tables
	option *DBMOption
}

func (dbm DBM) eventCoreConfigurationFunc(ctx context.Context, ef dml.EventFlag, e *CoreConfiguration) error {
	if dbm.option == nil || len(dbm.option.eventCoreConfigurationFunc[ef]) == 0 || dml.EventsAreSkipped(ctx) {
		return nil
	}
	for _, fn := range dbm.option.eventCoreConfigurationFunc[ef] {
		if err := fn(ctx, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventSalesOrderStatusStateFunc(ctx context.Context, ef dml.EventFlag, e *SalesOrderStatusState) error {
	if dbm.option == nil || len(dbm.option.eventSalesOrderStatusStateFunc[ef]) == 0 || dml.EventsAreSkipped(ctx) {
		return nil
	}
	for _, fn := range dbm.option.eventSalesOrderStatusStateFunc[ef] {
		if err := fn(ctx, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventViewCustomerAutoIncrementFunc(ctx context.Context, ef dml.EventFlag, e *ViewCustomerAutoIncrement) error {
	if dbm.option == nil || len(dbm.option.eventViewCustomerAutoIncrementFunc[ef]) == 0 || dml.EventsAreSkipped(ctx) {
		return nil
	}
	for _, fn := range dbm.option.eventViewCustomerAutoIncrementFunc[ef] {
		if err := fn(ctx, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

// NewDBManager returns a goified version of the MySQL/MariaDB table schema for
// the tables:  core_configuration, sales_order_status_state,
// view_customer_auto_increment Auto generated by dmlgen.
func NewDBManager(ctx context.Context, dbmo *DBMOption) (*DBM, error) {
	tbls, err := ddl.NewTables(append([]ddl.TableOption{ddl.WithCreateTable(ctx, TableNameCoreConfiguration, "", TableNameSalesOrderStatusState, "", TableNameViewCustomerAutoIncrement, "")}, dbmo.TableOptions...)...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	if dbmo.InitSelectFn == nil {
		dbmo.InitSelectFn = func(s *dml.Select) *dml.Select { return s }
	}
	if dbmo.InitInsertFn == nil {
		dbmo.InitInsertFn = func(s *dml.Insert) *dml.Insert { return s }
	}
	_ = tbls.Options(
		ddl.WithQueryDBR("CoreConfigurationFindByPK", dbmo.InitSelectFn(tbls.MustTable(TableNameCoreConfiguration).SelectByPK("*")).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CoreConfigurationUpsertByPK", dbmo.InitInsertFn(tbls.MustTable(TableNameCoreConfiguration).Insert()).OnDuplicateKey().WithDBR()),
		ddl.WithQueryDBR("SalesOrderStatusStateFindByPK", dbmo.InitSelectFn(tbls.MustTable(TableNameSalesOrderStatusState).SelectByPK("*")).WithDBR().Interpolate()),
		ddl.WithQueryDBR("ViewCustomerAutoIncrementFindByPK", dbmo.InitSelectFn(tbls.MustTable(TableNameViewCustomerAutoIncrement).SelectByPK("*")).WithDBR().Interpolate()),
	)
	return &DBM{Tables: tbls, option: dbmo}, nil
}

func (dbm DBM) CoreConfigurationFindByPK(ctx context.Context, configID uint32, opts ...dml.DBRFunc) (_ *CoreConfiguration, err error) {
	var e CoreConfiguration
	// put the IDs configID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeSelect, &e); err != nil {
		return nil, errors.WithStack(err)
	}
	if e.IsSet() {
		return &e, nil // returns data from cache
	}
	if _, err = dbm.CachedQuery("CoreConfigurationFindByPK").ApplyCallBacks(opts...).Load(ctx, &e, configID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterSelect, &e); err != nil {
		return nil, errors.WithStack(err)
	}
	return &e, nil
}

func (dbm DBM) CoreConfigurationUpsert(ctx context.Context, e *CoreConfiguration, opts ...dml.DBRFunc) (err error) {
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeUpsert, e); err != nil {
		return errors.WithStack(err)
	}
	if _, err = dbm.CachedQuery("CoreConfigurationUpsert").ApplyCallBacks(opts...).ExecContext(ctx, &e); err != nil {
		return errors.WithStack(err)
	}
	var e2 CoreConfiguration
	if _, err = dbm.CachedQuery("CoreConfigurationFindByPK").ApplyCallBacks(opts...).Load(ctx, &e2, e.ConfigID); err != nil {
		return errors.WithStack(err)
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterUpsert, &e2); err != nil {
		return errors.WithStack(err)
	}
	*e = e2
	return nil
}

func (dbm DBM) SalesOrderStatusStateFindByPK(ctx context.Context, status string, state string, opts ...dml.DBRFunc) (_ *SalesOrderStatusState, err error) {
	var e SalesOrderStatusState
	// put the IDs status,state into the context as value to search for a cache entry in the event function.
	if err = dbm.eventSalesOrderStatusStateFunc(ctx, dml.EventFlagBeforeSelect, &e); err != nil {
		return nil, errors.WithStack(err)
	}
	if e.IsSet() {
		return &e, nil // returns data from cache
	}
	if _, err = dbm.CachedQuery("SalesOrderStatusStateFindByPK").ApplyCallBacks(opts...).Load(ctx, &e, status, state); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventSalesOrderStatusStateFunc(ctx, dml.EventFlagAfterSelect, &e); err != nil {
		return nil, errors.WithStack(err)
	}
	return &e, nil
}

func (dbm DBM) ViewCustomerAutoIncrementFindByPK(ctx context.Context, ceEntityID uint32, opts ...dml.DBRFunc) (_ *ViewCustomerAutoIncrement, err error) {
	var e ViewCustomerAutoIncrement
	// put the IDs ceEntityID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventViewCustomerAutoIncrementFunc(ctx, dml.EventFlagBeforeSelect, &e); err != nil {
		return nil, errors.WithStack(err)
	}
	if e.IsSet() {
		return &e, nil // returns data from cache
	}
	if _, err = dbm.CachedQuery("ViewCustomerAutoIncrementFindByPK").ApplyCallBacks(opts...).Load(ctx, &e, ceEntityID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventViewCustomerAutoIncrementFunc(ctx, dml.EventFlagAfterSelect, &e); err != nil {
		return nil, errors.WithStack(err)
	}
	return &e, nil
}

// CoreConfiguration represents a single row for DB table core_configuration.
// Auto generated.
// Table comment: Config Data
type CoreConfiguration struct {
	ConfigID  uint32      `max_len:"10"` // config_id int(10) unsigned NOT NULL PRI  auto_increment "Id"
	Scope     string      `max_len:"8"`  // scope varchar(8) NOT NULL MUL DEFAULT ''default''  "Scope"
	ScopeID   int32       `max_len:"10"` // scope_id int(11) NOT NULL  DEFAULT '0'  "Scope Id"
	Expires   null.Time   // expires datetime NULL  DEFAULT 'NULL'  "Value expiration time"
	Path      string      `max_len:"255"`   // path varchar(255) NOT NULL    "Path"
	Value     null.String `max_len:"65535"` // value text NULL  DEFAULT 'NULL'  "Value"
	VersionTs time.Time   // version_ts timestamp(6) NOT NULL   STORED GENERATED "Timestamp Start Versioning"
	VersionTe time.Time   // version_te timestamp(6) NOT NULL PRI  STORED GENERATED "Timestamp End Versioning"
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CoreConfiguration) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint32(&e.ConfigID).String(&e.Scope).Int32(&e.ScopeID).NullTime(&e.Expires).String(&e.Path).NullString(&e.Value).Time(&e.VersionTs).Time(&e.VersionTe).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "config_id":
			cm.Uint32(&e.ConfigID)
		case "scope":
			cm.String(&e.Scope)
		case "scope_id":
			cm.Int32(&e.ScopeID)
		case "expires":
			cm.NullTime(&e.Expires)
		case "path":
			cm.String(&e.Path)
		case "value":
			cm.NullString(&e.Value)
		case "version_ts":
			cm.Time(&e.VersionTs)
		case "version_te":
			cm.Time(&e.VersionTe)
		default:
			return errors.NotFound.Newf("[dmltestgenerated2] CoreConfiguration Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *CoreConfiguration) IsSet() bool { return e.ConfigID > 0 }

// CoreConfigurations represents a collection type for DB table
// core_configuration
// Not thread safe. Auto generated.
type CoreConfigurations struct {
	Data []*CoreConfiguration `json:"data,omitempty"`
}

// NewCoreConfigurations  creates a new initialized collection. Auto generated.
func NewCoreConfigurations() *CoreConfigurations {
	return &CoreConfigurations{
		Data: make([]*CoreConfiguration, 0, 5),
	}
}

func (cc *CoreConfigurations) scanColumns(cm *dml.ColumnMap, e *CoreConfiguration, idx uint64) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CoreConfigurations) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for i, e := range cc.Data {
			if err := cc.scanColumns(cm, e, uint64(i)); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		e := new(CoreConfiguration)
		if err := cc.scanColumns(cm, e, cm.Count); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "config_id":
				cm = cm.Uint32s(cc.ConfigIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated2] CoreConfigurations Column %q not found", c)
			}
		} // end for cm.Next

	default:
		return errors.NotSupported.Newf("[dmltestgenerated2] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// ConfigIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CoreConfigurations) ConfigIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ConfigID)
	}
	return ret
}

// SalesOrderStatusState represents a single row for DB table
// sales_order_status_state. Auto generated.
// Table comment: Sales Order Status Table
type SalesOrderStatusState struct {
	Status         string // status varchar(32) NOT NULL PRI   "Status"
	State          string // state varchar(32) NOT NULL PRI   "Label"
	IsDefault      bool   // is_default smallint(5) unsigned NOT NULL  DEFAULT '0'  "Is Default"
	VisibleOnFront uint16 // visible_on_front smallint(5) unsigned NOT NULL  DEFAULT '0'  "Visible on front"
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *SalesOrderStatusState) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.String(&e.Status).String(&e.State).Bool(&e.IsDefault).Uint16(&e.VisibleOnFront).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "status":
			cm.String(&e.Status)
		case "state":
			cm.String(&e.State)
		case "is_default":
			cm.Bool(&e.IsDefault)
		case "visible_on_front":
			cm.Uint16(&e.VisibleOnFront)
		default:
			return errors.NotFound.Newf("[dmltestgenerated2] SalesOrderStatusState Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *SalesOrderStatusState) IsSet() bool { return e.Status != "" && e.State != "" }

// SalesOrderStatusStates represents a collection type for DB table
// sales_order_status_state
// Not thread safe. Auto generated.
type SalesOrderStatusStates struct {
	Data []*SalesOrderStatusState `json:"data,omitempty"`
}

// NewSalesOrderStatusStates  creates a new initialized collection. Auto
// generated.
func NewSalesOrderStatusStates() *SalesOrderStatusStates {
	return &SalesOrderStatusStates{
		Data: make([]*SalesOrderStatusState, 0, 5),
	}
}

func (cc *SalesOrderStatusStates) scanColumns(cm *dml.ColumnMap, e *SalesOrderStatusState, idx uint64) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *SalesOrderStatusStates) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for i, e := range cc.Data {
			if err := cc.scanColumns(cm, e, uint64(i)); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		e := new(SalesOrderStatusState)
		if err := cc.scanColumns(cm, e, cm.Count); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "status":
				cm = cm.Strings(cc.Statuss()...)
			case "state":
				cm = cm.Strings(cc.States()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated2] SalesOrderStatusStates Column %q not found", c)
			}
		} // end for cm.Next

	default:
		return errors.NotSupported.Newf("[dmltestgenerated2] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// Statuss returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *SalesOrderStatusStates) Statuss(ret ...string) []string {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]string, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.Status)
	}
	return ret
}

// States returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *SalesOrderStatusStates) States(ret ...string) []string {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]string, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.State)
	}
	return ret
}

// ViewCustomerAutoIncrement represents a single row for DB table
// view_customer_auto_increment. Auto generated.
// Table comment: VIEW
type ViewCustomerAutoIncrement struct {
	CeEntityID uint32      // ce_entity_id int(10) unsigned NOT NULL  DEFAULT '0'  "Entity ID"
	Email      null.String // email varchar(255) NULL  DEFAULT 'NULL'  "Email"
	Firstname  string      // firstname varchar(255) NOT NULL    "First Name"
	Lastname   string      // lastname varchar(255) NOT NULL    "Last Name"
	City       string      // city varchar(255) NOT NULL    "City"
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *ViewCustomerAutoIncrement) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint32(&e.CeEntityID).NullString(&e.Email).String(&e.Firstname).String(&e.Lastname).String(&e.City).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "ce_entity_id":
			cm.Uint32(&e.CeEntityID)
		case "email":
			cm.NullString(&e.Email)
		case "firstname":
			cm.String(&e.Firstname)
		case "lastname":
			cm.String(&e.Lastname)
		case "city":
			cm.String(&e.City)
		default:
			return errors.NotFound.Newf("[dmltestgenerated2] ViewCustomerAutoIncrement Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *ViewCustomerAutoIncrement) IsSet() bool { return e.CeEntityID > 0 }

// ViewCustomerAutoIncrements represents a collection type for DB table
// view_customer_auto_increment
// Not thread safe. Auto generated.
type ViewCustomerAutoIncrements struct {
	Data []*ViewCustomerAutoIncrement `json:"data,omitempty"`
}

// NewViewCustomerAutoIncrements  creates a new initialized collection. Auto
// generated.
func NewViewCustomerAutoIncrements() *ViewCustomerAutoIncrements {
	return &ViewCustomerAutoIncrements{
		Data: make([]*ViewCustomerAutoIncrement, 0, 5),
	}
}

func (cc *ViewCustomerAutoIncrements) scanColumns(cm *dml.ColumnMap, e *ViewCustomerAutoIncrement, idx uint64) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *ViewCustomerAutoIncrements) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for i, e := range cc.Data {
			if err := cc.scanColumns(cm, e, uint64(i)); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		e := new(ViewCustomerAutoIncrement)
		if err := cc.scanColumns(cm, e, cm.Count); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			default:
				return errors.NotFound.Newf("[dmltestgenerated2] ViewCustomerAutoIncrements Column %q not found", c)
			}
		} // end for cm.Next

	default:
		return errors.NotSupported.Newf("[dmltestgenerated2] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}
