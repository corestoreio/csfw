// Code generated by corestoreio/pkg/util/codegen. DO NOT EDIT.
// Generated by sql/dmlgen. DO NOT EDIT.
package dmltestgenerated5

import (
	"context"
	"database/sql"
	"fmt"
	"io"

	"github.com/corestoreio/errors"
	"github.com/corestoreio/pkg/sql/ddl"
	"github.com/corestoreio/pkg/sql/dml"
	"github.com/corestoreio/pkg/storage/null"
	"github.com/corestoreio/pkg/util/cstrace"
)

// CustomerAddressEntity represents a single row for DB table
// customer_address_entity. Auto generated.
// Table comment: Customer Address Entity
type CustomerAddressEntity struct {
	EntityID  uint32      `max_len:"10"`  // entity_id int(10) unsigned NOT NULL PRI  auto_increment "Entity ID"
	ParentID  null.Uint32 `max_len:"10"`  // parent_id int(10) unsigned NULL MUL DEFAULT 'NULL'  "Parent ID"
	City      string      `max_len:"255"` // city varchar(255) NOT NULL    "City"
	Company   null.String `max_len:"255"` // company varchar(255) NULL  DEFAULT 'NULL'  "Company"
	Firstname string      `max_len:"255"` // firstname varchar(255) NOT NULL    "First Name"
	Lastname  string      `max_len:"255"` // lastname varchar(255) NOT NULL    "Last Name"
}

type customerEntityRelations struct {
	parent                  *CustomerEntity
	CustomerAddressEntities *CustomerAddressEntities // Reversed 1:M customer_entity.entity_id => customer_address_entity.parent_id
	CustomerEntityInts      *CustomerEntityInts      // Reversed 1:M customer_entity.entity_id => customer_entity_int.entity_id
	CustomerEntityVarchars  *CustomerEntityVarchars  // Reversed 1:M customer_entity.entity_id => customer_entity_varchar.entity_id
}

func (e *CustomerEntity) setRelationParent() {
	if e.Relations != nil && e.Relations.parent == nil {
		e.Relations.parent = e
	}
}

func (e *CustomerEntity) NewRelations() *customerEntityRelations {
	e.Relations = &customerEntityRelations{parent: e}
	return e.Relations
}

// CustomerEntity represents a single row for DB table customer_entity. Auto
// generated.
// Table comment: Customer Entity
type CustomerEntity struct {
	EntityID  uint32      `max_len:"10"`  // entity_id int(10) unsigned NOT NULL PRI  auto_increment "Entity ID"
	WebsiteID null.Uint16 `max_len:"5"`   // website_id smallint(5) unsigned NULL MUL DEFAULT 'NULL'  "Website ID"
	Email     null.String `max_len:"255"` // email varchar(255) NULL MUL DEFAULT 'NULL'  "Email"
	Relations *customerEntityRelations
}

// CustomerEntityInt represents a single row for DB table customer_entity_int.
// Auto generated.
// Table comment: Customer Entity Int
type CustomerEntityInt struct {
	ValueID     int32  // value_id int(11) NOT NULL PRI  auto_increment "Value ID"
	AttributeID uint16 // attribute_id smallint(5) unsigned NOT NULL  DEFAULT '0'  "Attribute ID"
	EntityID    uint32 // entity_id int(10) unsigned NOT NULL MUL DEFAULT '0'  "Entity ID"
	Value       int32  // value int(11) NOT NULL  DEFAULT '0'  "Value"
}

// CustomerEntityVarchar represents a single row for DB table
// customer_entity_varchar. Auto generated.
// Table comment: Customer Entity Varchar
type CustomerEntityVarchar struct {
	ValueID     int32       // value_id int(11) NOT NULL PRI  auto_increment "Value ID"
	AttributeID uint16      // attribute_id smallint(5) unsigned NOT NULL  DEFAULT '0'  "Attribute ID"
	EntityID    uint32      // entity_id int(10) unsigned NOT NULL MUL DEFAULT '0'  "Entity ID"
	Value       null.String // value varchar(255) NULL  DEFAULT 'NULL'  "Value"
}

// TableName constants define the names of all tables.
const (
	TableNameCustomerAddressEntity = "customer_address_entity"
	TableNameCustomerEntity        = "customer_entity"
	TableNameCustomerEntityInt     = "customer_entity_int"
	TableNameCustomerEntityVarchar = "customer_entity_varchar"
)

// Columns struct provides for all tables the name of the columns. Allows type
// safety.
var Columns = struct {
	CustomerAddressEntity struct {
		EntityID  string
		ParentID  string
		City      string
		Company   string
		Firstname string
		Lastname  string
	}
	CustomerEntity struct {
		EntityID  string
		WebsiteID string
		Email     string
	}
	CustomerEntityInt struct {
		ValueID     string
		AttributeID string
		EntityID    string
		Value       string
	}
	CustomerEntityVarchar struct {
		ValueID     string
		AttributeID string
		EntityID    string
		Value       string
	}
}{
	CustomerAddressEntity: struct {
		EntityID  string
		ParentID  string
		City      string
		Company   string
		Firstname string
		Lastname  string
	}{
		EntityID:  "entity_id",
		ParentID:  "parent_id",
		City:      "city",
		Company:   "company",
		Firstname: "firstname",
		Lastname:  "lastname",
	},
	CustomerEntity: struct {
		EntityID  string
		WebsiteID string
		Email     string
	}{
		EntityID:  "entity_id",
		WebsiteID: "website_id",
		Email:     "email",
	},
	CustomerEntityInt: struct {
		ValueID     string
		AttributeID string
		EntityID    string
		Value       string
	}{
		ValueID:     "value_id",
		AttributeID: "attribute_id",
		EntityID:    "entity_id",
		Value:       "value",
	},
	CustomerEntityVarchar: struct {
		ValueID     string
		AttributeID string
		EntityID    string
		Value       string
	}{
		ValueID:     "value_id",
		AttributeID: "attribute_id",
		EntityID:    "entity_id",
		Value:       "value",
	},
}

// Event functions are getting dispatched during before or after handling a
// collection or an entity.
// Context is always non-nil but either collection or entity pointer will be set.
type (
	EventCustomerAddressEntityFn func(context.Context, *CustomerAddressEntities, *CustomerAddressEntity) error
	EventCustomerEntityFn        func(context.Context, *CustomerEntities, *CustomerEntity) error
	EventCustomerEntityIntFn     func(context.Context, *CustomerEntityInts, *CustomerEntityInt) error
	EventCustomerEntityVarcharFn func(context.Context, *CustomerEntityVarchars, *CustomerEntityVarchar) error
)

// DBMOption provides various options to the DBM object.
type DBMOption struct {
	Trace                          cstrace.Tracer
	TableOptions                   []ddl.TableOption // gets applied at the beginning
	TableOptionsAfter              []ddl.TableOption // gets applied at the end
	InitSelectFn                   func(*dml.Select) *dml.Select
	InitUpdateFn                   func(*dml.Update) *dml.Update
	InitDeleteFn                   func(*dml.Delete) *dml.Delete
	InitInsertFn                   func(*dml.Insert) *dml.Insert
	eventCustomerAddressEntityFunc [dml.EventFlagMax][]EventCustomerAddressEntityFn
	eventCustomerEntityFunc        [dml.EventFlagMax][]EventCustomerEntityFn
	eventCustomerEntityIntFunc     [dml.EventFlagMax][]EventCustomerEntityIntFn
	eventCustomerEntityVarcharFunc [dml.EventFlagMax][]EventCustomerEntityVarcharFn
}

// AddEventCustomerAddressEntity adds a specific defined event call back to the
// DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCustomerAddressEntity(event dml.EventFlag, fn EventCustomerAddressEntityFn) *DBMOption {
	o.eventCustomerAddressEntityFunc[event] = append(o.eventCustomerAddressEntityFunc[event], fn)
	return o
}

// AddEventCustomerEntity adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCustomerEntity(event dml.EventFlag, fn EventCustomerEntityFn) *DBMOption {
	o.eventCustomerEntityFunc[event] = append(o.eventCustomerEntityFunc[event], fn)
	return o
}

// AddEventCustomerEntityInt adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCustomerEntityInt(event dml.EventFlag, fn EventCustomerEntityIntFn) *DBMOption {
	o.eventCustomerEntityIntFunc[event] = append(o.eventCustomerEntityIntFunc[event], fn)
	return o
}

// AddEventCustomerEntityVarchar adds a specific defined event call back to the
// DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCustomerEntityVarchar(event dml.EventFlag, fn EventCustomerEntityVarcharFn) *DBMOption {
	o.eventCustomerEntityVarcharFunc[event] = append(o.eventCustomerEntityVarcharFunc[event], fn)
	return o
}

// DBM defines the DataBaseManagement object for the tables
// customer_address_entity, customer_entity, customer_entity_int,
// customer_entity_varchar
type DBM struct {
	*ddl.Tables
	option DBMOption
}

func (dbm DBM) eventCustomerAddressEntityFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *CustomerAddressEntities, e *CustomerAddressEntity) error {
	if len(dbm.option.eventCustomerAddressEntityFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventCustomerAddressEntityFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventCustomerEntityFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *CustomerEntities, e *CustomerEntity) error {
	if len(dbm.option.eventCustomerEntityFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventCustomerEntityFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventCustomerEntityIntFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *CustomerEntityInts, e *CustomerEntityInt) error {
	if len(dbm.option.eventCustomerEntityIntFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventCustomerEntityIntFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventCustomerEntityVarcharFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *CustomerEntityVarchars, e *CustomerEntityVarchar) error {
	if len(dbm.option.eventCustomerEntityVarcharFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventCustomerEntityVarcharFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

// NewDBManager returns a goified version of the MySQL/MariaDB table schema for
// the tables:  customer_address_entity, customer_entity, customer_entity_int,
// customer_entity_varchar Auto generated by dmlgen.
func NewDBManager(ctx context.Context, dbmo *DBMOption) (*DBM, error) {
	tbls, err := ddl.NewTables(append([]ddl.TableOption{ddl.WithCreateTable(ctx, TableNameCustomerAddressEntity, "", TableNameCustomerEntity, "", TableNameCustomerEntityInt, "", TableNameCustomerEntityVarchar, "")}, dbmo.TableOptions...)...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	if dbmo.InitSelectFn == nil {
		dbmo.InitSelectFn = func(s *dml.Select) *dml.Select { return s }
	}
	if dbmo.InitUpdateFn == nil {
		dbmo.InitUpdateFn = func(s *dml.Update) *dml.Update { return s }
	}
	if dbmo.InitDeleteFn == nil {
		dbmo.InitDeleteFn = func(s *dml.Delete) *dml.Delete { return s }
	}
	if dbmo.InitInsertFn == nil {
		dbmo.InitInsertFn = func(s *dml.Insert) *dml.Insert { return s }
	}
	err = tbls.Options(
		ddl.WithQueryDBR(map[string]dml.QueryBuilder{
			"CustomerAddressEntitiesSelectAll": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerAddressEntity).Select("*")),
			"CustomerAddressEntitiesSelectByPK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerAddressEntity).Select("*")).Where(
				dml.Column(`entity_id`).In().PlaceHolder(),
			),
			"CustomerAddressEntitySelectByPK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerAddressEntity).Select("*")).Where(
				dml.Column(`entity_id`).Equal().PlaceHolder(),
			),
			"CustomerAddressEntityUpdateByPK": dbmo.InitUpdateFn(tbls.MustTable(TableNameCustomerAddressEntity).Update().Where(
				dml.Column(`entity_id`).Equal().PlaceHolder(),
			)),
			"CustomerAddressEntityDeleteByPK": dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerAddressEntity).Delete().Where(
				dml.Column(`entity_id`).In().PlaceHolder(),
			)),
			"CustomerAddressEntityInsert":     dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerAddressEntity).Insert()),
			"CustomerAddressEntityUpsertByPK": dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerAddressEntity).Insert()).OnDuplicateKey(),
			"CustomerEntitiesSelectAll":       dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntity).Select("*")),
			"CustomerEntitiesSelectByPK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntity).Select("*")).Where(
				dml.Column(`entity_id`).In().PlaceHolder(),
			),
			"CustomerEntitySelectByPK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntity).Select("*")).Where(
				dml.Column(`entity_id`).Equal().PlaceHolder(),
			),
			"CustomerEntityUpdateByPK": dbmo.InitUpdateFn(tbls.MustTable(TableNameCustomerEntity).Update().Where(
				dml.Column(`entity_id`).Equal().PlaceHolder(),
			)),
			"CustomerEntityDeleteByPK": dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerEntity).Delete().Where(
				dml.Column(`entity_id`).In().PlaceHolder(),
			)),
			"CustomerEntityInsert":     dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerEntity).Insert()),
			"CustomerEntityUpsertByPK": dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerEntity).Insert()).OnDuplicateKey(),
			// <FOREIGN_KEY_QUERIES customer_entity >
			"CustomerAddressEntitiesDeleteByFK": dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerAddressEntity).Delete().Where(
				dml.Column(`parent_id`).Equal().PlaceHolder(),
			)),
			"CustomerAddressEntitiesSelectByFK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerAddressEntity).Select("*").Where(
				dml.Column(`parent_id`).Equal().PlaceHolder(),
			)),
			"CustomerEntityIntsDeleteByFK": dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerEntityInt).Delete().Where(
				dml.Column(`entity_id`).Equal().PlaceHolder(),
			)),
			"CustomerEntityIntsSelectByFK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntityInt).Select("*").Where(
				dml.Column(`entity_id`).Equal().PlaceHolder(),
			)),
			"CustomerEntityVarcharsDeleteByFK": dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerEntityVarchar).Delete().Where(
				dml.Column(`entity_id`).Equal().PlaceHolder(),
			)),
			"CustomerEntityVarcharsSelectByFK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntityVarchar).Select("*").Where(
				dml.Column(`entity_id`).Equal().PlaceHolder(),
			)),
			// </FOREIGN_KEY_QUERIES customer_entity >
			"CustomerEntityIntsSelectAll": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntityInt).Select("*")),
			"CustomerEntityIntsSelectByPK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntityInt).Select("*")).Where(
				dml.Column(`value_id`).In().PlaceHolder(),
			),
			"CustomerEntityIntSelectByPK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntityInt).Select("*")).Where(
				dml.Column(`value_id`).Equal().PlaceHolder(),
			),
			"CustomerEntityIntUpdateByPK": dbmo.InitUpdateFn(tbls.MustTable(TableNameCustomerEntityInt).Update().Where(
				dml.Column(`value_id`).Equal().PlaceHolder(),
			)),
			"CustomerEntityIntDeleteByPK": dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerEntityInt).Delete().Where(
				dml.Column(`value_id`).In().PlaceHolder(),
			)),
			"CustomerEntityIntInsert":         dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerEntityInt).Insert()),
			"CustomerEntityIntUpsertByPK":     dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerEntityInt).Insert()).OnDuplicateKey(),
			"CustomerEntityVarcharsSelectAll": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntityVarchar).Select("*")),
			"CustomerEntityVarcharsSelectByPK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntityVarchar).Select("*")).Where(
				dml.Column(`value_id`).In().PlaceHolder(),
			),
			"CustomerEntityVarcharSelectByPK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntityVarchar).Select("*")).Where(
				dml.Column(`value_id`).Equal().PlaceHolder(),
			),
			"CustomerEntityVarcharUpdateByPK": dbmo.InitUpdateFn(tbls.MustTable(TableNameCustomerEntityVarchar).Update().Where(
				dml.Column(`value_id`).Equal().PlaceHolder(),
			)),
			"CustomerEntityVarcharDeleteByPK": dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerEntityVarchar).Delete().Where(
				dml.Column(`value_id`).In().PlaceHolder(),
			)),
			"CustomerEntityVarcharInsert":     dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerEntityVarchar).Insert()),
			"CustomerEntityVarcharUpsertByPK": dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerEntityVarchar).Insert()).OnDuplicateKey(),
		}),
	)
	if err != nil {
		return nil, err
	}
	if err := tbls.Options(dbmo.TableOptionsAfter...); err != nil {
		return nil, err
	}
	if dbmo.Trace == nil {
		dbmo.Trace = cstrace.NewNoopTracerProvider().Tracer("")
	}
	return &DBM{Tables: tbls, option: *dbmo}, nil
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerAddressEntity) AssignLastInsertID(id int64) {
	e.EntityID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerAddressEntity) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(6) {
		switch c := cm.Column(); c {
		case "entity_id", "0":
			cm.Uint32(&e.EntityID)
		case "parent_id", "1":
			cm.NullUint32(&e.ParentID)
		case "city", "2":
			cm.String(&e.City)
		case "company", "3":
			cm.NullString(&e.Company)
		case "firstname", "4":
			cm.String(&e.Firstname)
		case "lastname", "5":
			cm.String(&e.Lastname)
		default:
			return errors.NotFound.Newf("[dmltestgenerated5] CustomerAddressEntity Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

func (e *CustomerAddressEntity) Load(ctx context.Context, dbm *DBM, primaryKey uint32, opts ...dml.DBRFunc) (err error) {
	if e == nil {
		return errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	// put the IDs primaryKey into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeSelect, qo.SkipEvents, nil, e); err != nil {
		return errors.WithStack(err)
	}
	if e.IsSet() {
		return nil // might return data from cache
	}
	if _, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntitySelectByPK", opts...).Load(ctx, e, primaryKey); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterSelect, qo.SkipEvents, nil, e))
}

func (e *CustomerAddressEntity) Delete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeDelete, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntityDeleteByPK", opts...).ExecContext(ctx, e.EntityID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterDelete, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerAddressEntity) Update(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeUpdate, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntityUpdateByPK", opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterUpdate, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerAddressEntity) Insert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeInsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntityInsert", opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterInsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerAddressEntity) Upsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeUpsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntityUpsertByPK", opts...).ExecContext(ctx, dml.Qualify("", e)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterUpsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *CustomerAddressEntity) IsSet() bool { return e.EntityID > 0 }

// CustomerAddressEntities represents a collection type for DB table
// customer_address_entity
// Not thread safe. Auto generated.
type CustomerAddressEntities struct {
	Data []*CustomerAddressEntity `json:"data,omitempty"`
}

// NewCustomerAddressEntities  creates a new initialized collection. Auto
// generated.
func NewCustomerAddressEntities() *CustomerAddressEntities {
	return &CustomerAddressEntities{
		Data: make([]*CustomerAddressEntity, 0, 5),
	}
}

// Clear will reset the data slice or create a new type. Useful for reusing the
// underlying backing slice array. Auto generated via dmlgen.
func (cc *CustomerAddressEntities) Clear() *CustomerAddressEntities {
	if cc == nil {
		*cc = CustomerAddressEntities{}
		return cc
	}
	if c := cap(cc.Data); c > len(cc.Data) {
		cc.Data = cc.Data[:c]
	}
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i] = nil
	}
	cc.Data = cc.Data[:0]
	return cc
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CustomerAddressEntities) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CustomerAddressEntities) scanColumns(cm *dml.ColumnMap, e *CustomerAddressEntity) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CustomerAddressEntities) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e CustomerAddressEntity
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "entity_id":
				cm = cm.Uint32s(cc.EntityIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated5] CustomerAddressEntities Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgenerated5] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

func (cc *CustomerAddressEntities) DBLoad(ctx context.Context, dbm *DBM, pkIDs []uint32, opts ...dml.DBRFunc) (err error) {
	cc.Clear()
	qo := dml.FromContextQueryOptions(ctx)
	// put the IDs EntityID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeSelect, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if cc.Data != nil {
		return nil // might return data from cache
	}
	if len(pkIDs) > 0 {
		if _, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntitiesSelectByPK", opts...).Load(ctx, cc, pkIDs); err != nil {
			return errors.WithStack(err)
		}
	} else {
		if _, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntitiesSelectAll", opts...).Load(ctx, cc); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterSelect, qo.SkipEvents, cc, nil))
}

func (cc *CustomerAddressEntities) DBDelete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntities can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeDelete, qo.SkipEvents, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntityDeleteByPK", opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterDelete, qo.SkipEvents, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CustomerAddressEntities) DBUpdate(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if cc == nil {
		return errors.NotValid.Newf("CustomerAddressEntities can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeUpdate, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerAddressEntityUpdateByPK", opts...)
	dbrStmt, err := dbr.Prepare(ctx)
	if err != nil {
		return errors.WithStack(err)
	}
	for _, c := range cc.Data {
		res, err := dbrStmt.ExecContext(ctx, c)
		if err := dbr.ResultCheckFn(TableNameCustomerAddressEntity, 1, res, err); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterUpdate, qo.SkipEvents, cc, nil))
}

func (cc *CustomerAddressEntities) DBInsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if cc == nil {
		return errors.NotValid.Newf("CustomerAddressEntities can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err := dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeInsert, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerAddressEntityInsert", opts...)
	res, err := dbr.ExecContext(ctx, cc)
	if err := dbr.ResultCheckFn(TableNameCustomerAddressEntity, len(cc.Data), res, err); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterInsert, qo.SkipEvents, cc, nil))
}

func (cc *CustomerAddressEntities) DBUpsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if cc == nil {
		return errors.NotValid.Newf("CustomerAddressEntities can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err := dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeUpsert, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerAddressEntityUpsertByPK", opts...)
	res, err := dbr.ExecContext(ctx, dml.Qualify("", cc))
	if err := dbr.ResultCheckFn(TableNameCustomerAddressEntity, len(cc.Data), res, err); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterUpsert, qo.SkipEvents, cc, nil))
}

// Each will run function f on all items in []* CustomerAddressEntity . Auto
// generated via dmlgen.
func (cc *CustomerAddressEntities) Each(f func(*CustomerAddressEntity)) *CustomerAddressEntities {
	if cc == nil {
		return nil
	}
	for i := range cc.Data {
		f(cc.Data[i])
	}
	return cc
}

// EntityIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CustomerAddressEntities) EntityIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.EntityID)
	}
	return ret
}

func (r *customerEntityRelations) DeleteCustomerAddressEntities(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	dbr := dbm.ConnPool.WithCacheKey("CustomerAddressEntitiesDeleteByFK", opts...)
	res, err := dbr.ExecContext(ctx, r.parent.EntityID)
	err = dbr.ResultCheckFn(TableNameCustomerAddressEntity, len(r.CustomerAddressEntities.Data), res, err)
	if err == nil && r.CustomerAddressEntities != nil {
		r.CustomerAddressEntities.Clear()
	}
	return errors.WithStack(err)
}

func (r *customerEntityRelations) InsertCustomerAddressEntities(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if r.CustomerAddressEntities == nil || len(r.CustomerAddressEntities.Data) == 0 {
		return nil
	}
	for _, e2 := range r.CustomerAddressEntities.Data {
		e2.ParentID = null.MakeUint32(uint32(r.parent.EntityID))
	}
	return errors.WithStack(r.CustomerAddressEntities.DBInsert(ctx, dbm, opts...))
}

func (r *customerEntityRelations) UpdateCustomerAddressEntities(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if r.CustomerAddressEntities == nil || len(r.CustomerAddressEntities.Data) == 0 {
		dbr := dbm.ConnPool.WithCacheKey("CustomerAddressEntitiesDeleteByFK", opts...)
		res, err := dbr.ExecContext(ctx, r.parent.EntityID)
		return dbr.ResultCheckFn(TableNameCustomerAddressEntity, -1, res, errors.WithStack(err))
	}
	for _, e2 := range r.CustomerAddressEntities.Data {
		e2.ParentID = null.MakeUint32(uint32(r.parent.EntityID))
	}
	err = r.CustomerAddressEntities.DBUpdate(ctx, dbm, opts...)
	return errors.WithStack(err)
}

func (r *customerEntityRelations) LoadCustomerAddressEntities(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (rowCount uint64, err error) {
	if r.CustomerAddressEntities == nil {
		r.CustomerAddressEntities = &CustomerAddressEntities{}
	}
	r.CustomerAddressEntities.Clear()
	rowCount, err = dbm.ConnPool.WithCacheKey("CustomerAddressEntitiesSelectByFK", opts...).Load(ctx, r.CustomerAddressEntities, r.parent.EntityID)
	return rowCount, errors.WithStack(err)
}

func (r *customerEntityRelations) DeleteCustomerEntityInts(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityIntsDeleteByFK", opts...)
	res, err := dbr.ExecContext(ctx, r.parent.EntityID)
	err = dbr.ResultCheckFn(TableNameCustomerEntityInt, len(r.CustomerEntityInts.Data), res, err)
	if err == nil && r.CustomerEntityInts != nil {
		r.CustomerEntityInts.Clear()
	}
	return errors.WithStack(err)
}

func (r *customerEntityRelations) InsertCustomerEntityInts(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if r.CustomerEntityInts == nil || len(r.CustomerEntityInts.Data) == 0 {
		return nil
	}
	for _, e2 := range r.CustomerEntityInts.Data {
		e2.EntityID = r.parent.EntityID
	}
	return errors.WithStack(r.CustomerEntityInts.DBInsert(ctx, dbm, opts...))
}

func (r *customerEntityRelations) UpdateCustomerEntityInts(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if r.CustomerEntityInts == nil || len(r.CustomerEntityInts.Data) == 0 {
		dbr := dbm.ConnPool.WithCacheKey("CustomerEntityIntsDeleteByFK", opts...)
		res, err := dbr.ExecContext(ctx, r.parent.EntityID)
		return dbr.ResultCheckFn(TableNameCustomerEntityInt, -1, res, errors.WithStack(err))
	}
	for _, e2 := range r.CustomerEntityInts.Data {
		e2.EntityID = r.parent.EntityID
	}
	err = r.CustomerEntityInts.DBUpdate(ctx, dbm, opts...)
	return errors.WithStack(err)
}

func (r *customerEntityRelations) LoadCustomerEntityInts(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (rowCount uint64, err error) {
	if r.CustomerEntityInts == nil {
		r.CustomerEntityInts = &CustomerEntityInts{}
	}
	r.CustomerEntityInts.Clear()
	rowCount, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntsSelectByFK", opts...).Load(ctx, r.CustomerEntityInts, r.parent.EntityID)
	return rowCount, errors.WithStack(err)
}

func (r *customerEntityRelations) DeleteCustomerEntityVarchars(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityVarcharsDeleteByFK", opts...)
	res, err := dbr.ExecContext(ctx, r.parent.EntityID)
	err = dbr.ResultCheckFn(TableNameCustomerEntityVarchar, len(r.CustomerEntityVarchars.Data), res, err)
	if err == nil && r.CustomerEntityVarchars != nil {
		r.CustomerEntityVarchars.Clear()
	}
	return errors.WithStack(err)
}

func (r *customerEntityRelations) InsertCustomerEntityVarchars(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if r.CustomerEntityVarchars == nil || len(r.CustomerEntityVarchars.Data) == 0 {
		return nil
	}
	for _, e2 := range r.CustomerEntityVarchars.Data {
		e2.EntityID = r.parent.EntityID
	}
	return errors.WithStack(r.CustomerEntityVarchars.DBInsert(ctx, dbm, opts...))
}

func (r *customerEntityRelations) UpdateCustomerEntityVarchars(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if r.CustomerEntityVarchars == nil || len(r.CustomerEntityVarchars.Data) == 0 {
		dbr := dbm.ConnPool.WithCacheKey("CustomerEntityVarcharsDeleteByFK", opts...)
		res, err := dbr.ExecContext(ctx, r.parent.EntityID)
		return dbr.ResultCheckFn(TableNameCustomerEntityVarchar, -1, res, errors.WithStack(err))
	}
	for _, e2 := range r.CustomerEntityVarchars.Data {
		e2.EntityID = r.parent.EntityID
	}
	err = r.CustomerEntityVarchars.DBUpdate(ctx, dbm, opts...)
	return errors.WithStack(err)
}

func (r *customerEntityRelations) LoadCustomerEntityVarchars(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (rowCount uint64, err error) {
	if r.CustomerEntityVarchars == nil {
		r.CustomerEntityVarchars = &CustomerEntityVarchars{}
	}
	r.CustomerEntityVarchars.Clear()
	rowCount, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharsSelectByFK", opts...).Load(ctx, r.CustomerEntityVarchars, r.parent.EntityID)
	return rowCount, errors.WithStack(err)
}

func (r *customerEntityRelations) InsertAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.InsertCustomerAddressEntities(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.InsertCustomerEntityInts(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.InsertCustomerEntityVarchars(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *customerEntityRelations) LoadAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if _, err = r.LoadCustomerAddressEntities(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if _, err = r.LoadCustomerEntityInts(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if _, err = r.LoadCustomerEntityVarchars(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *customerEntityRelations) UpdateAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.UpdateCustomerAddressEntities(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.UpdateCustomerEntityInts(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.UpdateCustomerEntityVarchars(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *customerEntityRelations) DeleteAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.DeleteCustomerAddressEntities(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.DeleteCustomerEntityInts(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.DeleteCustomerEntityVarchars(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerEntity) AssignLastInsertID(id int64) {
	e.EntityID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerEntity) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(3) {
		switch c := cm.Column(); c {
		case "entity_id", "0":
			cm.Uint32(&e.EntityID)
		case "website_id", "1":
			cm.NullUint16(&e.WebsiteID)
		case "email", "2":
			cm.NullString(&e.Email)
		default:
			return errors.NotFound.Newf("[dmltestgenerated5] CustomerEntity Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

func (e *CustomerEntity) Load(ctx context.Context, dbm *DBM, primaryKey uint32, opts ...dml.DBRFunc) (err error) {
	if e == nil {
		return errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	e.setRelationParent()
	qo := dml.FromContextQueryOptions(ctx)
	// put the IDs primaryKey into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeSelect, qo.SkipEvents, nil, e); err != nil {
		return errors.WithStack(err)
	}
	if e.IsSet() {
		return nil // might return data from cache
	}
	if _, err = dbm.ConnPool.WithCacheKey("CustomerEntitySelectByPK", opts...).Load(ctx, e, primaryKey); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterSelect, qo.SkipEvents, nil, e))
}

func (e *CustomerEntity) Delete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	e.setRelationParent()
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeDelete, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityDeleteByPK", opts...).ExecContext(ctx, e.EntityID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterDelete, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntity) Update(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	e.setRelationParent()
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeUpdate, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityUpdateByPK", opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterUpdate, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntity) Insert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	e.setRelationParent()
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeInsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityInsert", opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterInsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntity) Upsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	e.setRelationParent()
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeUpsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityUpsertByPK", opts...).ExecContext(ctx, dml.Qualify("", e)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterUpsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *CustomerEntity) IsSet() bool { return e.EntityID > 0 }

// CustomerEntities represents a collection type for DB table customer_entity
// Not thread safe. Auto generated.
type CustomerEntities struct {
	Data []*CustomerEntity `json:"data,omitempty"`
}

// NewCustomerEntities  creates a new initialized collection. Auto generated.
func NewCustomerEntities() *CustomerEntities {
	return &CustomerEntities{
		Data: make([]*CustomerEntity, 0, 5),
	}
}

// Clear will reset the data slice or create a new type. Useful for reusing the
// underlying backing slice array. Auto generated via dmlgen.
func (cc *CustomerEntities) Clear() *CustomerEntities {
	if cc == nil {
		*cc = CustomerEntities{}
		return cc
	}
	if c := cap(cc.Data); c > len(cc.Data) {
		cc.Data = cc.Data[:c]
	}
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i] = nil
	}
	cc.Data = cc.Data[:0]
	return cc
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CustomerEntities) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CustomerEntities) scanColumns(cm *dml.ColumnMap, e *CustomerEntity) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CustomerEntities) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e CustomerEntity
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "entity_id":
				cm = cm.Uint32s(cc.EntityIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated5] CustomerEntities Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgenerated5] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

func (cc *CustomerEntities) DBLoad(ctx context.Context, dbm *DBM, pkIDs []uint32, opts ...dml.DBRFunc) (err error) {
	cc.Clear()
	qo := dml.FromContextQueryOptions(ctx)
	// put the IDs EntityID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeSelect, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if cc.Data != nil {
		return nil // might return data from cache
	}
	if len(pkIDs) > 0 {
		if _, err = dbm.ConnPool.WithCacheKey("CustomerEntitiesSelectByPK", opts...).Load(ctx, cc, pkIDs); err != nil {
			return errors.WithStack(err)
		}
	} else {
		if _, err = dbm.ConnPool.WithCacheKey("CustomerEntitiesSelectAll", opts...).Load(ctx, cc); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterSelect, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntities) DBDelete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerEntities can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeDelete, qo.SkipEvents, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityDeleteByPK", opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterDelete, qo.SkipEvents, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CustomerEntities) DBUpdate(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntities can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeUpdate, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityUpdateByPK", opts...)
	dbrStmt, err := dbr.Prepare(ctx)
	if err != nil {
		return errors.WithStack(err)
	}
	for _, c := range cc.Data {
		res, err := dbrStmt.ExecContext(ctx, c)
		if err := dbr.ResultCheckFn(TableNameCustomerEntity, 1, res, err); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterUpdate, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntities) DBInsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntities can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err := dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeInsert, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityInsert", opts...)
	res, err := dbr.ExecContext(ctx, cc)
	if err := dbr.ResultCheckFn(TableNameCustomerEntity, len(cc.Data), res, err); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterInsert, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntities) DBUpsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntities can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err := dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeUpsert, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityUpsertByPK", opts...)
	res, err := dbr.ExecContext(ctx, dml.Qualify("", cc))
	if err := dbr.ResultCheckFn(TableNameCustomerEntity, len(cc.Data), res, err); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterUpsert, qo.SkipEvents, cc, nil))
}

// Each will run function f on all items in []* CustomerEntity . Auto generated
// via dmlgen.
func (cc *CustomerEntities) Each(f func(*CustomerEntity)) *CustomerEntities {
	if cc == nil {
		return nil
	}
	for i := range cc.Data {
		f(cc.Data[i])
	}
	return cc
}

// EntityIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CustomerEntities) EntityIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.EntityID)
	}
	return ret
}

// Copy copies the struct and returns a new pointer. TODO use deepcopy tool to
// generate code afterwards
func (e *CustomerEntityInt) Copy() *CustomerEntityInt {
	if e == nil {
		return &CustomerEntityInt{}
	}
	e2 := *e // for now a shallow copy
	return &e2
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerEntityInt) AssignLastInsertID(id int64) {
	e.ValueID = int32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerEntityInt) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(4) {
		switch c := cm.Column(); c {
		case "value_id", "0":
			cm.Int32(&e.ValueID)
		case "attribute_id", "1":
			cm.Uint16(&e.AttributeID)
		case "entity_id", "2":
			cm.Uint32(&e.EntityID)
		case "value", "3":
			cm.Int32(&e.Value)
		default:
			return errors.NotFound.Newf("[dmltestgenerated5] CustomerEntityInt Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

func (e *CustomerEntityInt) Load(ctx context.Context, dbm *DBM, primaryKey int32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntSelectByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return errors.NotValid.Newf("CustomerEntityInt can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	// put the IDs primaryKey into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeSelect, qo.SkipEvents, nil, e); err != nil {
		return errors.WithStack(err)
	}
	if e.IsSet() {
		return nil // might return data from cache
	}
	if _, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntSelectByPK", opts...).Load(ctx, e, primaryKey); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterSelect, qo.SkipEvents, nil, e))
}

func (e *CustomerEntityInt) Delete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntityInt can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeDelete, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntDeleteByPK", opts...).ExecContext(ctx, e.ValueID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterDelete, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntityInt) Update(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntityInt can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeUpdate, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntUpdateByPK", opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterUpdate, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntityInt) Insert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntityInt can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeInsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntInsert", opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterInsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntityInt) Upsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntityInt can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeUpsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntUpsertByPK", opts...).ExecContext(ctx, dml.Qualify("", e)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterUpsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// Empty empties all the fields of the current object. Also known as Reset.
func (e *CustomerEntityInt) Empty() *CustomerEntityInt { *e = CustomerEntityInt{}; return e }

// IsSet returns true if the entity has non-empty primary keys.
func (e *CustomerEntityInt) IsSet() bool { return e.ValueID != 0 }

// This variable can be set in another file to provide a custom validator.
var validateCustomerEntityInt func(*CustomerEntityInt) error

// Validate runs internal consistency tests.
func (e *CustomerEntityInt) Validate() error {
	if e == nil {
		return errors.NotValid.Newf("Type %T cannot be nil", e)
	}
	if validateCustomerEntityInt != nil {
		return validateCustomerEntityInt(e)
	}
	return nil
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (e *CustomerEntityInt) WriteTo(w io.Writer) (n int64, err error) {
	// for now this printing is good enough. If you need better swap out with your code.
	n2, err := fmt.Fprint(w,
		"value_id:", e.ValueID, "\n",
		"attribute_id:", e.AttributeID, "\n",
		"entity_id:", e.EntityID, "\n",
		"value:", e.Value, "\n",
	)
	return int64(n2), err
}

// CustomerEntityInts represents a collection type for DB table
// customer_entity_int
// Not thread safe. Auto generated.
type CustomerEntityInts struct {
	Data []*CustomerEntityInt `json:"data,omitempty"`
}

// NewCustomerEntityInts  creates a new initialized collection. Auto generated.
func NewCustomerEntityInts() *CustomerEntityInts {
	return &CustomerEntityInts{
		Data: make([]*CustomerEntityInt, 0, 5),
	}
}

// Append will add a new item at the end of * CustomerEntityInts . Auto generated
// via dmlgen.
func (cc *CustomerEntityInts) Append(n ...*CustomerEntityInt) *CustomerEntityInts {
	cc.Data = append(cc.Data, n...)
	return cc
}

// Clear will reset the data slice or create a new type. Useful for reusing the
// underlying backing slice array. Auto generated via dmlgen.
func (cc *CustomerEntityInts) Clear() *CustomerEntityInts {
	if cc == nil {
		*cc = CustomerEntityInts{}
		return cc
	}
	if c := cap(cc.Data); c > len(cc.Data) {
		cc.Data = cc.Data[:c]
	}
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i] = nil
	}
	cc.Data = cc.Data[:0]
	return cc
}

// Cut will remove items i through j-1. Auto generated via dmlgen.
func (cc *CustomerEntityInts) Cut(i, j int) *CustomerEntityInts {
	z := cc.Data // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k] = nil // this avoids the memory leak
	}
	z = z[:len(z)-j+i]
	cc.Data = z
	return cc
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CustomerEntityInts) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CustomerEntityInts) scanColumns(cm *dml.ColumnMap, e *CustomerEntityInt) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CustomerEntityInts) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e CustomerEntityInt
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "value_id":
				cm = cm.Int32s(cc.ValueIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated5] CustomerEntityInts Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgenerated5] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

func (cc *CustomerEntityInts) DBLoad(ctx context.Context, dbm *DBM, pkIDs []int32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntsDBLoad")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	cc.Clear()
	qo := dml.FromContextQueryOptions(ctx)
	// put the IDs ValueID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeSelect, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if cc.Data != nil {
		return nil // might return data from cache
	}
	if len(pkIDs) > 0 {
		if _, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntsSelectByPK", opts...).Load(ctx, cc, pkIDs); err != nil {
			return errors.WithStack(err)
		}
	} else {
		if _, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntsSelectAll", opts...).Load(ctx, cc); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterSelect, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntityInts) DBDelete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntsDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerEntityInts can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeDelete, qo.SkipEvents, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityIntDeleteByPK", opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterDelete, qo.SkipEvents, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CustomerEntityInts) DBUpdate(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntsUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntityInts can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeUpdate, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityIntUpdateByPK", opts...)
	dbrStmt, err := dbr.Prepare(ctx)
	if err != nil {
		return errors.WithStack(err)
	}
	for _, c := range cc.Data {
		res, err := dbrStmt.ExecContext(ctx, c)
		if err := dbr.ResultCheckFn(TableNameCustomerEntityInt, 1, res, err); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterUpdate, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntityInts) DBInsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntsInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntityInts can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err := dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeInsert, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityIntInsert", opts...)
	res, err := dbr.ExecContext(ctx, cc)
	if err := dbr.ResultCheckFn(TableNameCustomerEntityInt, len(cc.Data), res, err); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterInsert, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntityInts) DBUpsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityIntsUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntityInts can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err := dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagBeforeUpsert, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityIntUpsertByPK", opts...)
	res, err := dbr.ExecContext(ctx, dml.Qualify("", cc))
	if err := dbr.ResultCheckFn(TableNameCustomerEntityInt, len(cc.Data), res, err); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityIntFunc(ctx, dml.EventFlagAfterUpsert, qo.SkipEvents, cc, nil))
}

// Delete will remove an item from the slice. Auto generated via dmlgen.
func (cc *CustomerEntityInts) Delete(i int) *CustomerEntityInts {
	z := cc.Data // copy the slice header
	end := len(z) - 1
	cc.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = nil // this should avoid the memory leak
	z = z[:end]
	cc.Data = z
	return cc
}

// Each will run function f on all items in []* CustomerEntityInt . Auto
// generated via dmlgen.
func (cc *CustomerEntityInts) Each(f func(*CustomerEntityInt)) *CustomerEntityInts {
	if cc == nil {
		return nil
	}
	for i := range cc.Data {
		f(cc.Data[i])
	}
	return cc
}

// Filter filters the current slice by predicate f without memory allocation.
// Auto generated via dmlgen.
func (cc *CustomerEntityInts) Filter(f func(*CustomerEntityInt) bool) *CustomerEntityInts {
	if cc == nil {
		return nil
	}
	b, i := cc.Data[:0], 0
	for _, e := range cc.Data {
		if f(e) {
			b = append(b, e)
		}
		i++
	}
	for i := len(b); i < len(cc.Data); i++ {
		cc.Data[i] = nil // this should avoid the memory leak
	}
	cc.Data = b
	return cc
}

// Insert will place a new item at position i. Auto generated via dmlgen.
func (cc *CustomerEntityInts) Insert(n *CustomerEntityInt, i int) *CustomerEntityInts {
	z := cc.Data // copy the slice header
	z = append(z, &CustomerEntityInt{})
	copy(z[i+1:], z[i:])
	z[i] = n
	cc.Data = z
	return cc
}

// Swap will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CustomerEntityInts) Swap(i, j int) { cc.Data[i], cc.Data[j] = cc.Data[j], cc.Data[i] }

// Len will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CustomerEntityInts) Len() int {
	if cc == nil {
		return 0
	}
	return len(cc.Data)
}

// ValueIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CustomerEntityInts) ValueIDs(ret ...int32) []int32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]int32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ValueID)
	}
	return ret
}

// Validate runs internal consistency tests on all items.
func (cc *CustomerEntityInts) Validate() (err error) {
	if len(cc.Data) == 0 {
		return nil
	}
	for i, ld := 0, len(cc.Data); i < ld && err == nil; i++ {
		err = cc.Data[i].Validate()
	}
	return
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (cc *CustomerEntityInts) WriteTo(w io.Writer) (n int64, err error) {
	for i, d := range cc.Data {
		n2, err := d.WriteTo(w)
		if err != nil {
			return 0, errors.Wrapf(err, "[dmltestgenerated5] WriteTo failed at index %d", i)
		}
		n += n2
	}
	return n, nil
}

// Copy copies the struct and returns a new pointer. TODO use deepcopy tool to
// generate code afterwards
func (e *CustomerEntityVarchar) Copy() *CustomerEntityVarchar {
	if e == nil {
		return &CustomerEntityVarchar{}
	}
	e2 := *e // for now a shallow copy
	return &e2
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerEntityVarchar) AssignLastInsertID(id int64) {
	e.ValueID = int32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerEntityVarchar) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(4) {
		switch c := cm.Column(); c {
		case "value_id", "0":
			cm.Int32(&e.ValueID)
		case "attribute_id", "1":
			cm.Uint16(&e.AttributeID)
		case "entity_id", "2":
			cm.Uint32(&e.EntityID)
		case "value", "3":
			cm.NullString(&e.Value)
		default:
			return errors.NotFound.Newf("[dmltestgenerated5] CustomerEntityVarchar Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

func (e *CustomerEntityVarchar) Load(ctx context.Context, dbm *DBM, primaryKey int32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharSelectByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return errors.NotValid.Newf("CustomerEntityVarchar can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	// put the IDs primaryKey into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeSelect, qo.SkipEvents, nil, e); err != nil {
		return errors.WithStack(err)
	}
	if e.IsSet() {
		return nil // might return data from cache
	}
	if _, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharSelectByPK", opts...).Load(ctx, e, primaryKey); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterSelect, qo.SkipEvents, nil, e))
}

func (e *CustomerEntityVarchar) Delete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntityVarchar can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeDelete, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharDeleteByPK", opts...).ExecContext(ctx, e.ValueID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterDelete, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntityVarchar) Update(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntityVarchar can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeUpdate, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharUpdateByPK", opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterUpdate, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntityVarchar) Insert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntityVarchar can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeInsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharInsert", opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterInsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntityVarchar) Upsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntityVarchar can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeUpsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharUpsertByPK", opts...).ExecContext(ctx, dml.Qualify("", e)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterUpsert, qo.SkipEvents, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// Empty empties all the fields of the current object. Also known as Reset.
func (e *CustomerEntityVarchar) Empty() *CustomerEntityVarchar {
	*e = CustomerEntityVarchar{}
	return e
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *CustomerEntityVarchar) IsSet() bool { return e.ValueID != 0 }

// This variable can be set in another file to provide a custom validator.
var validateCustomerEntityVarchar func(*CustomerEntityVarchar) error

// Validate runs internal consistency tests.
func (e *CustomerEntityVarchar) Validate() error {
	if e == nil {
		return errors.NotValid.Newf("Type %T cannot be nil", e)
	}
	if validateCustomerEntityVarchar != nil {
		return validateCustomerEntityVarchar(e)
	}
	return nil
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (e *CustomerEntityVarchar) WriteTo(w io.Writer) (n int64, err error) {
	// for now this printing is good enough. If you need better swap out with your code.
	n2, err := fmt.Fprint(w,
		"value_id:", e.ValueID, "\n",
		"attribute_id:", e.AttributeID, "\n",
		"entity_id:", e.EntityID, "\n",
		"value:", e.Value, "\n",
	)
	return int64(n2), err
}

// CustomerEntityVarchars represents a collection type for DB table
// customer_entity_varchar
// Not thread safe. Auto generated.
type CustomerEntityVarchars struct {
	Data []*CustomerEntityVarchar `json:"data,omitempty"`
}

// NewCustomerEntityVarchars  creates a new initialized collection. Auto
// generated.
func NewCustomerEntityVarchars() *CustomerEntityVarchars {
	return &CustomerEntityVarchars{
		Data: make([]*CustomerEntityVarchar, 0, 5),
	}
}

// Append will add a new item at the end of * CustomerEntityVarchars . Auto
// generated via dmlgen.
func (cc *CustomerEntityVarchars) Append(n ...*CustomerEntityVarchar) *CustomerEntityVarchars {
	cc.Data = append(cc.Data, n...)
	return cc
}

// Clear will reset the data slice or create a new type. Useful for reusing the
// underlying backing slice array. Auto generated via dmlgen.
func (cc *CustomerEntityVarchars) Clear() *CustomerEntityVarchars {
	if cc == nil {
		*cc = CustomerEntityVarchars{}
		return cc
	}
	if c := cap(cc.Data); c > len(cc.Data) {
		cc.Data = cc.Data[:c]
	}
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i] = nil
	}
	cc.Data = cc.Data[:0]
	return cc
}

// Cut will remove items i through j-1. Auto generated via dmlgen.
func (cc *CustomerEntityVarchars) Cut(i, j int) *CustomerEntityVarchars {
	z := cc.Data // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k] = nil // this avoids the memory leak
	}
	z = z[:len(z)-j+i]
	cc.Data = z
	return cc
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CustomerEntityVarchars) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CustomerEntityVarchars) scanColumns(cm *dml.ColumnMap, e *CustomerEntityVarchar) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CustomerEntityVarchars) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e CustomerEntityVarchar
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "value_id":
				cm = cm.Int32s(cc.ValueIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated5] CustomerEntityVarchars Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgenerated5] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

func (cc *CustomerEntityVarchars) DBLoad(ctx context.Context, dbm *DBM, pkIDs []int32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharsDBLoad")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	cc.Clear()
	qo := dml.FromContextQueryOptions(ctx)
	// put the IDs ValueID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeSelect, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if cc.Data != nil {
		return nil // might return data from cache
	}
	if len(pkIDs) > 0 {
		if _, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharsSelectByPK", opts...).Load(ctx, cc, pkIDs); err != nil {
			return errors.WithStack(err)
		}
	} else {
		if _, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharsSelectAll", opts...).Load(ctx, cc); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterSelect, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntityVarchars) DBDelete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharsDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerEntityVarchars can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeDelete, qo.SkipEvents, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.ConnPool.WithCacheKey("CustomerEntityVarcharDeleteByPK", opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterDelete, qo.SkipEvents, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CustomerEntityVarchars) DBUpdate(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharsUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntityVarchars can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err = dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeUpdate, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityVarcharUpdateByPK", opts...)
	dbrStmt, err := dbr.Prepare(ctx)
	if err != nil {
		return errors.WithStack(err)
	}
	for _, c := range cc.Data {
		res, err := dbrStmt.ExecContext(ctx, c)
		if err := dbr.ResultCheckFn(TableNameCustomerEntityVarchar, 1, res, err); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterUpdate, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntityVarchars) DBInsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharsInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntityVarchars can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err := dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeInsert, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityVarcharInsert", opts...)
	res, err := dbr.ExecContext(ctx, cc)
	if err := dbr.ResultCheckFn(TableNameCustomerEntityVarchar, len(cc.Data), res, err); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterInsert, qo.SkipEvents, cc, nil))
}

func (cc *CustomerEntityVarchars) DBUpsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityVarcharsUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntityVarchars can't be nil")
	}
	qo := dml.FromContextQueryOptions(ctx)
	if err := dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagBeforeUpsert, qo.SkipEvents, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	dbr := dbm.ConnPool.WithCacheKey("CustomerEntityVarcharUpsertByPK", opts...)
	res, err := dbr.ExecContext(ctx, dml.Qualify("", cc))
	if err := dbr.ResultCheckFn(TableNameCustomerEntityVarchar, len(cc.Data), res, err); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityVarcharFunc(ctx, dml.EventFlagAfterUpsert, qo.SkipEvents, cc, nil))
}

// Delete will remove an item from the slice. Auto generated via dmlgen.
func (cc *CustomerEntityVarchars) Delete(i int) *CustomerEntityVarchars {
	z := cc.Data // copy the slice header
	end := len(z) - 1
	cc.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = nil // this should avoid the memory leak
	z = z[:end]
	cc.Data = z
	return cc
}

// Each will run function f on all items in []* CustomerEntityVarchar . Auto
// generated via dmlgen.
func (cc *CustomerEntityVarchars) Each(f func(*CustomerEntityVarchar)) *CustomerEntityVarchars {
	if cc == nil {
		return nil
	}
	for i := range cc.Data {
		f(cc.Data[i])
	}
	return cc
}

// Filter filters the current slice by predicate f without memory allocation.
// Auto generated via dmlgen.
func (cc *CustomerEntityVarchars) Filter(f func(*CustomerEntityVarchar) bool) *CustomerEntityVarchars {
	if cc == nil {
		return nil
	}
	b, i := cc.Data[:0], 0
	for _, e := range cc.Data {
		if f(e) {
			b = append(b, e)
		}
		i++
	}
	for i := len(b); i < len(cc.Data); i++ {
		cc.Data[i] = nil // this should avoid the memory leak
	}
	cc.Data = b
	return cc
}

// Insert will place a new item at position i. Auto generated via dmlgen.
func (cc *CustomerEntityVarchars) Insert(n *CustomerEntityVarchar, i int) *CustomerEntityVarchars {
	z := cc.Data // copy the slice header
	z = append(z, &CustomerEntityVarchar{})
	copy(z[i+1:], z[i:])
	z[i] = n
	cc.Data = z
	return cc
}

// Swap will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CustomerEntityVarchars) Swap(i, j int) { cc.Data[i], cc.Data[j] = cc.Data[j], cc.Data[i] }

// Len will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CustomerEntityVarchars) Len() int {
	if cc == nil {
		return 0
	}
	return len(cc.Data)
}

// ValueIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CustomerEntityVarchars) ValueIDs(ret ...int32) []int32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]int32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ValueID)
	}
	return ret
}

// Validate runs internal consistency tests on all items.
func (cc *CustomerEntityVarchars) Validate() (err error) {
	if len(cc.Data) == 0 {
		return nil
	}
	for i, ld := 0, len(cc.Data); i < ld && err == nil; i++ {
		err = cc.Data[i].Validate()
	}
	return
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (cc *CustomerEntityVarchars) WriteTo(w io.Writer) (n int64, err error) {
	for i, d := range cc.Data {
		n2, err := d.WriteTo(w)
		if err != nil {
			return 0, errors.Wrapf(err, "[dmltestgenerated5] WriteTo failed at index %d", i)
		}
		n += n2
	}
	return n, nil
}
