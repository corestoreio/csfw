// Code generated by codegen. DO NOT EDIT.
// Generated by sql/dmlgen. DO NOT EDIT.
// +build !ignore
// +build !ignored

package dmltestgenerated

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"sync"
	"time"

	"github.com/corestoreio/errors"
	"github.com/corestoreio/pkg/sql/ddl"
	"github.com/corestoreio/pkg/sql/dml"
	"github.com/corestoreio/pkg/storage/null"
	"github.com/corestoreio/pkg/util/cstrace"
	"go.opentelemetry.io/otel/api/trace"
)

// TableName constants define the names of all tables.
const (
	TableNameCoreConfiguration     = "core_configuration"
	TableNameCustomerAddressEntity = "customer_address_entity"
	TableNameCustomerEntity        = "customer_entity"
)

// Columns struct provides for all tables the name of the columns. Allows type
// safety.
var Columns = struct {
	CoreConfiguration struct {
		ConfigID  string
		Scope     string
		ScopeID   string
		Expires   string
		Path      string
		Value     string
		VersionTs string
		VersionTe string
	}
	CustomerAddressEntity struct {
		EntityID          string
		IncrementID       string
		ParentID          string
		CreatedAt         string
		UpdatedAt         string
		IsActive          string
		City              string
		Company           string
		CountryID         string
		Fax               string
		Firstname         string
		Lastname          string
		Middlename        string
		Postcode          string
		Prefix            string
		Region            string
		RegionID          string
		Street            string
		Suffix            string
		Telephone         string
		VatID             string
		VatIsValid        string
		VatRequestDate    string
		VatRequestID      string
		VatRequestSuccess string
	}
	CustomerEntity struct {
		EntityID               string
		WebsiteID              string
		Email                  string
		GroupID                string
		IncrementID            string
		StoreID                string
		CreatedAt              string
		UpdatedAt              string
		IsActive               string
		DisableAutoGroupChange string
		CreatedIn              string
		Prefix                 string
		Firstname              string
		Middlename             string
		Lastname               string
		Suffix                 string
		Dob                    string
		passwordHash           string
		RpToken                string
		RpTokenCreatedAt       string
		DefaultBilling         string
		DefaultShipping        string
		Taxvat                 string
		Confirmation           string
		Gender                 string
		FailuresNum            string
		FirstFailure           string
		LockExpires            string
	}
}{
	CoreConfiguration: struct {
		ConfigID  string
		Scope     string
		ScopeID   string
		Expires   string
		Path      string
		Value     string
		VersionTs string
		VersionTe string
	}{
		ConfigID:  "config_id",
		Scope:     "scope",
		ScopeID:   "scope_id",
		Expires:   "expires",
		Path:      "path",
		Value:     "value",
		VersionTs: "version_ts",
		VersionTe: "version_te",
	},
	CustomerAddressEntity: struct {
		EntityID          string
		IncrementID       string
		ParentID          string
		CreatedAt         string
		UpdatedAt         string
		IsActive          string
		City              string
		Company           string
		CountryID         string
		Fax               string
		Firstname         string
		Lastname          string
		Middlename        string
		Postcode          string
		Prefix            string
		Region            string
		RegionID          string
		Street            string
		Suffix            string
		Telephone         string
		VatID             string
		VatIsValid        string
		VatRequestDate    string
		VatRequestID      string
		VatRequestSuccess string
	}{
		EntityID:          "entity_id",
		IncrementID:       "increment_id",
		ParentID:          "parent_id",
		CreatedAt:         "created_at",
		UpdatedAt:         "updated_at",
		IsActive:          "is_active",
		City:              "city",
		Company:           "company",
		CountryID:         "country_id",
		Fax:               "fax",
		Firstname:         "firstname",
		Lastname:          "lastname",
		Middlename:        "middlename",
		Postcode:          "postcode",
		Prefix:            "prefix",
		Region:            "region",
		RegionID:          "region_id",
		Street:            "street",
		Suffix:            "suffix",
		Telephone:         "telephone",
		VatID:             "vat_id",
		VatIsValid:        "vat_is_valid",
		VatRequestDate:    "vat_request_date",
		VatRequestID:      "vat_request_id",
		VatRequestSuccess: "vat_request_success",
	},
	CustomerEntity: struct {
		EntityID               string
		WebsiteID              string
		Email                  string
		GroupID                string
		IncrementID            string
		StoreID                string
		CreatedAt              string
		UpdatedAt              string
		IsActive               string
		DisableAutoGroupChange string
		CreatedIn              string
		Prefix                 string
		Firstname              string
		Middlename             string
		Lastname               string
		Suffix                 string
		Dob                    string
		passwordHash           string
		RpToken                string
		RpTokenCreatedAt       string
		DefaultBilling         string
		DefaultShipping        string
		Taxvat                 string
		Confirmation           string
		Gender                 string
		FailuresNum            string
		FirstFailure           string
		LockExpires            string
	}{
		EntityID:               "entity_id",
		WebsiteID:              "website_id",
		Email:                  "email",
		GroupID:                "group_id",
		IncrementID:            "increment_id",
		StoreID:                "store_id",
		CreatedAt:              "created_at",
		UpdatedAt:              "updated_at",
		IsActive:               "is_active",
		DisableAutoGroupChange: "disable_auto_group_change",
		CreatedIn:              "created_in",
		Prefix:                 "prefix",
		Firstname:              "firstname",
		Middlename:             "middlename",
		Lastname:               "lastname",
		Suffix:                 "suffix",
		Dob:                    "dob",
		passwordHash:           "password_hash",
		RpToken:                "rp_token",
		RpTokenCreatedAt:       "rp_token_created_at",
		DefaultBilling:         "default_billing",
		DefaultShipping:        "default_shipping",
		Taxvat:                 "taxvat",
		Confirmation:           "confirmation",
		Gender:                 "gender",
		FailuresNum:            "failures_num",
		FirstFailure:           "first_failure",
		LockExpires:            "lock_expires",
	},
}

var dbmEmptyOpts = []dml.DBRFunc{func(dbr *dml.DBR) {
	// do nothing because Clone gets called automatically
}}

func dbmNoopResultCheckFn(_ sql.Result, err error) error { return err }

// Event functions are getting dispatched during before or after handling a
// collection or an entity.
// Context is always non-nil but either collection or entity pointer will be set.
type (
	EventCoreConfigurationFn     func(context.Context, *CoreConfigurations, *CoreConfiguration) error
	EventCustomerAddressEntityFn func(context.Context, *CustomerAddressEntities, *CustomerAddressEntity) error
	EventCustomerEntityFn        func(context.Context, *CustomerEntities, *CustomerEntity) error
)

// DBMOption provides various options to the DBM object.
type DBMOption struct {
	Trace                          trace.Tracer
	TableOptions                   []ddl.TableOption // gets applied at the beginning
	TableOptionsAfter              []ddl.TableOption // gets applied at the end
	InitSelectFn                   func(*dml.Select) *dml.Select
	InitUpdateFn                   func(*dml.Update) *dml.Update
	InitDeleteFn                   func(*dml.Delete) *dml.Delete
	InitInsertFn                   func(*dml.Insert) *dml.Insert
	eventCoreConfigurationFunc     [dml.EventFlagMax][]EventCoreConfigurationFn
	eventCustomerAddressEntityFunc [dml.EventFlagMax][]EventCustomerAddressEntityFn
	eventCustomerEntityFunc        [dml.EventFlagMax][]EventCustomerEntityFn
}

// AddEventCoreConfiguration adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCoreConfiguration(event dml.EventFlag, fn EventCoreConfigurationFn) *DBMOption {
	o.eventCoreConfigurationFunc[event] = append(o.eventCoreConfigurationFunc[event], fn)
	return o
}

// AddEventCustomerAddressEntity adds a specific defined event call back to the
// DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCustomerAddressEntity(event dml.EventFlag, fn EventCustomerAddressEntityFn) *DBMOption {
	o.eventCustomerAddressEntityFunc[event] = append(o.eventCustomerAddressEntityFunc[event], fn)
	return o
}

// AddEventCustomerEntity adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCustomerEntity(event dml.EventFlag, fn EventCustomerEntityFn) *DBMOption {
	o.eventCustomerEntityFunc[event] = append(o.eventCustomerEntityFunc[event], fn)
	return o
}

// DBM defines the DataBaseManagement object for the tables  core_configuration,
// customer_address_entity, customer_entity
type DBM struct {
	*ddl.Tables
	option DBMOption

	querymu sync.RWMutex
	selects map[string]*dml.Select
}

func (dbm DBM) eventCoreConfigurationFunc(ctx context.Context, ef dml.EventFlag, ec *CoreConfigurations, e *CoreConfiguration) error {
	if len(dbm.option.eventCoreConfigurationFunc[ef]) == 0 || dml.EventsAreSkipped(ctx) {
		return nil
	}
	for _, fn := range dbm.option.eventCoreConfigurationFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventCustomerAddressEntityFunc(ctx context.Context, ef dml.EventFlag, ec *CustomerAddressEntities, e *CustomerAddressEntity) error {
	if len(dbm.option.eventCustomerAddressEntityFunc[ef]) == 0 || dml.EventsAreSkipped(ctx) {
		return nil
	}
	for _, fn := range dbm.option.eventCustomerAddressEntityFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventCustomerEntityFunc(ctx context.Context, ef dml.EventFlag, ec *CustomerEntities, e *CustomerEntity) error {
	if len(dbm.option.eventCustomerEntityFunc[ef]) == 0 || dml.EventsAreSkipped(ctx) {
		return nil
	}
	for _, fn := range dbm.option.eventCustomerEntityFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

// NewDBManager returns a goified version of the MySQL/MariaDB table schema for
// the tables:  core_configuration, customer_address_entity, customer_entity Auto
// generated by dmlgen.
func NewDBManager(ctx context.Context, dbmo *DBMOption) (*DBM, error) {
	tbls, err := ddl.NewTables(append([]ddl.TableOption{ddl.WithCreateTable(ctx, TableNameCoreConfiguration, "", TableNameCustomerAddressEntity, "", TableNameCustomerEntity, "")}, dbmo.TableOptions...)...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	if dbmo.InitSelectFn == nil {
		dbmo.InitSelectFn = func(s *dml.Select) *dml.Select { return s }
	}
	if dbmo.InitUpdateFn == nil {
		dbmo.InitUpdateFn = func(s *dml.Update) *dml.Update { return s }
	}
	if dbmo.InitDeleteFn == nil {
		dbmo.InitDeleteFn = func(s *dml.Delete) *dml.Delete { return s }
	}
	if dbmo.InitInsertFn == nil {
		dbmo.InitInsertFn = func(s *dml.Insert) *dml.Insert { return s }
	}
	err = tbls.Options(
		ddl.WithQueryDBR("CoreConfigurationsSelectAll", dbmo.InitSelectFn(tbls.MustTable(TableNameCoreConfiguration).Select("*")).WithDBR()),
		ddl.WithQueryDBR("CoreConfigurationsSelectByPK", dbmo.InitSelectFn(tbls.MustTable(TableNameCoreConfiguration).Select("*")).Where(
			dml.Column(`config_id`).In().PlaceHolder(),
		).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CoreConfigurationUpdateByPK", dbmo.InitUpdateFn(tbls.MustTable(TableNameCoreConfiguration).Update().Where(
			dml.Column(`config_id`).Equal().PlaceHolder(),
		)).WithDBR()),
		ddl.WithQueryDBR("CoreConfigurationDeleteByPK", dbmo.InitDeleteFn(tbls.MustTable(TableNameCoreConfiguration).Delete().Where(
			dml.Column(`config_id`).In().PlaceHolder(),
		)).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CoreConfigurationInsert", dbmo.InitInsertFn(tbls.MustTable(TableNameCoreConfiguration).Insert()).WithDBR()),
		ddl.WithQueryDBR("CoreConfigurationUpsertByPK", dbmo.InitInsertFn(tbls.MustTable(TableNameCoreConfiguration).Insert()).OnDuplicateKey().WithDBR()),
		ddl.WithQueryDBR("CustomerAddressEntitiesSelectAll", dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerAddressEntity).Select("*")).WithDBR()),
		ddl.WithQueryDBR("CustomerAddressEntitiesSelectByPK", dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerAddressEntity).Select("*")).Where(
			dml.Column(`entity_id`).In().PlaceHolder(),
		).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CustomerAddressEntitySelectByPK", dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerAddressEntity).Select("*")).Where(
			dml.Column(`entity_id`).Equal().PlaceHolder(),
		).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CustomerAddressEntityUpdateByPK", dbmo.InitUpdateFn(tbls.MustTable(TableNameCustomerAddressEntity).Update().Where(
			dml.Column(`entity_id`).Equal().PlaceHolder(),
		)).WithDBR()),
		ddl.WithQueryDBR("CustomerAddressEntityDeleteByPK", dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerAddressEntity).Delete().Where(
			dml.Column(`entity_id`).In().PlaceHolder(),
		)).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CustomerAddressEntityInsert", dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerAddressEntity).Insert()).WithDBR()),
		ddl.WithQueryDBR("CustomerAddressEntityUpsertByPK", dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerAddressEntity).Insert()).OnDuplicateKey().WithDBR()),
		ddl.WithQueryDBR("CustomerEntitiesSelectAll", dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntity).Select("*")).WithDBR()),
		ddl.WithQueryDBR("CustomerEntitiesSelectByPK", dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntity).Select("*")).Where(
			dml.Column(`entity_id`).In().PlaceHolder(),
		).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CustomerEntitySelectByPK", dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerEntity).Select("*")).Where(
			dml.Column(`entity_id`).Equal().PlaceHolder(),
		).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CustomerEntityUpdateByPK", dbmo.InitUpdateFn(tbls.MustTable(TableNameCustomerEntity).Update().Where(
			dml.Column(`entity_id`).Equal().PlaceHolder(),
		)).WithDBR()),
		ddl.WithQueryDBR("CustomerEntityDeleteByPK", dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerEntity).Delete().Where(
			dml.Column(`entity_id`).In().PlaceHolder(),
		)).WithDBR().Interpolate()),
		ddl.WithQueryDBR("CustomerEntityInsert", dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerEntity).Insert()).WithDBR()),
		ddl.WithQueryDBR("CustomerEntityUpsertByPK", dbmo.InitInsertFn(tbls.MustTable(TableNameCustomerEntity).Insert()).OnDuplicateKey().WithDBR()),
	)
	if err != nil {
		return nil, err
	}
	if err := tbls.Options(dbmo.TableOptionsAfter...); err != nil {
		return nil, err
	}
	if dbmo.Trace == nil {
		dbmo.Trace = trace.NoopTracer{}
	}
	return &DBM{Tables: tbls, option: *dbmo}, nil
}

// CoreConfiguration represents a single row for DB table core_configuration.
// Auto generated.
// Table comment: Config Data
//easyjson:json
type CoreConfiguration struct {
	ConfigID  uint32      `json:"config_id,omitempty" max_len:"10"`  // config_id int(10) unsigned NOT NULL PRI  auto_increment "Id"
	Scope     string      `json:"scope,omitempty" max_len:"8"`       // scope varchar(8) NOT NULL MUL DEFAULT ''default''  "Scope"
	ScopeID   int32       `json:"scope_id" xml:"scope_id"`           // scope_id int(11) NOT NULL  DEFAULT '0'  "Scope Id"
	Expires   null.Time   `json:"expires,omitempty" `                // expires datetime NULL  DEFAULT 'NULL'  "Value expiration time"
	Path      string      `json:"x_path" xml:"y_path" max_len:"255"` // path varchar(255) NOT NULL  DEFAULT ''general''  "Config Path overwritten"
	Value     null.String `json:"value,omitempty" max_len:"65535"`   // value text NULL  DEFAULT 'NULL'  "Value"
	VersionTs time.Time   `json:"version_ts,omitempty" `             // version_ts timestamp(6) NOT NULL   STORED GENERATED "Timestamp Start Versioning"
	VersionTe time.Time   `json:"version_te,omitempty" `             // version_te timestamp(6) NOT NULL PRI  STORED GENERATED "Timestamp End Versioning"
}

// Copy copies the struct and returns a new pointer. TODO use deepcopy tool to
// generate code afterwards
func (e *CoreConfiguration) Copy() *CoreConfiguration {
	e2 := new(CoreConfiguration)
	*e2 = *e // for now a shallow copy
	return e2
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CoreConfiguration) AssignLastInsertID(id int64) {
	e.ConfigID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CoreConfiguration) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint32(&e.ConfigID).String(&e.Scope).Int32(&e.ScopeID).NullTime(&e.Expires).String(&e.Path).NullString(&e.Value).Time(&e.VersionTs).Time(&e.VersionTe).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "config_id":
			cm.Uint32(&e.ConfigID)
		case "scope":
			cm.String(&e.Scope)
		case "scope_id":
			cm.Int32(&e.ScopeID)
		case "expires":
			cm.NullTime(&e.Expires)
		case "path", "storage_location", "config_directory":
			cm.String(&e.Path)
		case "value":
			cm.NullString(&e.Value)
		case "version_ts":
			cm.Time(&e.VersionTs)
		case "version_te":
			cm.Time(&e.VersionTe)
		default:
			return errors.NotFound.Newf("[dmltestgenerated] CoreConfiguration Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

func (e *CoreConfiguration) Load(ctx context.Context, dbm *DBM, primaryKey uint32, opts ...func(*dml.Select)) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationSelectByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return errors.NotValid.Newf("CoreConfiguration can't be nil")
	}
	// put the IDs primaryKey into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeSelect, nil, e); err != nil {
		return errors.WithStack(err)
	}
	if e.IsSet() {
		return nil // might return data from cache
	}

	if sel, ok := dbm.selects["CoreConfigurationSelectByPK"]; ok {
		dbm.MustTable(TableNameCoreConfiguration).Select("*").Where(
			dml.Column(`config_id`).Equal().PlaceHolder(),
		).WithCacheKey()
	} else {
		opts[0](dbm.MustTable(TableNameCoreConfiguration).Select("*").Where(
			dml.Column(`config_id`).Equal().PlaceHolder(),
		).WithCacheKey())
	}

	if _, err = dbm.CachedQuery("CoreConfigurationSelectByPK").ApplyCallBacks(opts...).Load(ctx, e, primaryKey); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterSelect, nil, e))
}

func (e *CoreConfiguration) Delete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CoreConfiguration can't be nil")
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeDelete, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CoreConfigurationDeleteByPK").ApplyCallBacks(opts...).ExecContext(ctx, e.ConfigID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterDelete, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CoreConfiguration) Update(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CoreConfiguration can't be nil")
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeUpdate, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CoreConfigurationUpdateByPK").ApplyCallBacks(opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterUpdate, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CoreConfiguration) Insert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CoreConfiguration can't be nil")
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeInsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CoreConfigurationInsert").ApplyCallBacks(opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterInsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CoreConfiguration) Upsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CoreConfiguration can't be nil")
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeUpsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CoreConfigurationUpsertByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", e)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterUpsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// Empty empties all the fields of the current object. Also known as Reset.
func (e *CoreConfiguration) Empty() *CoreConfiguration { *e = CoreConfiguration{}; return e }

// IsSet returns true if the entity has non-empty primary keys.
func (e *CoreConfiguration) IsSet() bool { return e.ConfigID > 0 }

// This variable can be set in another file to provide a custom validator.
var validateCoreConfiguration func(*CoreConfiguration) error

// Validate runs internal consistency tests.
func (e *CoreConfiguration) Validate() error {
	if e == nil {
		return errors.NotValid.Newf("Type %T cannot be nil", e)
	}
	if validateCoreConfiguration != nil {
		return validateCoreConfiguration(e)
	}
	return nil
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (e *CoreConfiguration) WriteTo(w io.Writer) (n int64, err error) {
	// for now this printing is good enough. If you need better swap out with your code.
	n2, err := fmt.Fprint(w,
		"config_id:", e.ConfigID, "\n",
		"scope:", e.Scope, "\n",
		"scope_id:", e.ScopeID, "\n",
		"expires:", e.Expires, "\n",
		"path:", e.Path, "\n",
		"value:", e.Value, "\n",
		"version_ts:", e.VersionTs, "\n",
		"version_te:", e.VersionTe, "\n",
	)
	return int64(n2), err
}

// CoreConfigurations represents a collection type for DB table
// core_configuration
// Not thread safe. Auto generated.
//easyjson:json
type CoreConfigurations struct {
	Data []*CoreConfiguration `json:"data,omitempty"`
}

// NewCoreConfigurations  creates a new initialized collection. Auto generated.
func NewCoreConfigurations() *CoreConfigurations {
	return &CoreConfigurations{
		Data: make([]*CoreConfiguration, 0, 5),
	}
}

// Append will add a new item at the end of * CoreConfigurations . Auto generated
// via dmlgen.
func (cc *CoreConfigurations) Append(n ...*CoreConfiguration) *CoreConfigurations {
	cc.Data = append(cc.Data, n...)
	return cc
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (cc *CoreConfigurations) UnmarshalBinary(data []byte) error {
	return cc.Unmarshal(data) // Implemented via github.com/gogo/protobuf
}

// MarshalBinary implements encoding.BinaryMarshaler.
func (cc *CoreConfigurations) MarshalBinary() (data []byte, err error) {
	return cc.Marshal() // Implemented via github.com/gogo/protobuf
}

// Cut will remove items i through j-1. Auto generated via dmlgen.
func (cc *CoreConfigurations) Cut(i, j int) *CoreConfigurations {
	z := cc.Data // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k] = nil // this avoids the memory leak
	}
	z = z[:len(z)-j+i]
	cc.Data = z
	return cc
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CoreConfigurations) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CoreConfigurations) scanColumns(cm *dml.ColumnMap, e *CoreConfiguration) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CoreConfigurations) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		var e CoreConfiguration
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "config_id":
				cm = cm.Uint32s(cc.ConfigIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated] CoreConfigurations Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgenerated] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

func (cc *CoreConfigurations) DBLoad(ctx context.Context, dbm *DBM, pkIDs []uint32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationsDBLoad")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CoreConfiguration can't be nil")
	}
	// put the IDs ConfigID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeSelect, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if cc.Data != nil {
		return nil // might return data from cache
	}
	if len(pkIDs) > 0 {
		if _, err = dbm.CachedQuery("CoreConfigurationsSelectByPK").ApplyCallBacks(opts...).Load(ctx, cc, pkIDs); err != nil {
			return errors.WithStack(err)
		}
	} else {
		if _, err = dbm.CachedQuery("CoreConfigurationsSelectAll").ApplyCallBacks(opts...).Load(ctx, cc); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterSelect, cc, nil))
}

func (cc *CoreConfigurations) DBDelete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationsDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CoreConfigurations can't be nil")
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeDelete, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CoreConfigurationDeleteByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterDelete, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CoreConfigurations) DBUpdate(ctx context.Context, dbm *DBM, resCheckFn func(sql.Result, error) error, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationsUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CoreConfigurations can't be nil")
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeUpdate, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if len(opts) == 0 {
		opts = dbmEmptyOpts
	}
	if resCheckFn == nil {
		resCheckFn = dbmNoopResultCheckFn
	}
	dbrStmt, err := dbm.CachedQuery("CoreConfigurationUpdateByPK").ApplyCallBacks(opts...).Prepare(ctx)
	if err != nil {
		return errors.WithStack(err)
	}
	for _, c := range cc.Data {
		if err := resCheckFn(dbrStmt.ExecContext(ctx, c)); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterUpdate, cc, nil))
}

func (cc *CoreConfigurations) DBInsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationsInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CoreConfigurations can't be nil")
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeInsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CoreConfigurationInsert").ApplyCallBacks(opts...).ExecContext(ctx, cc); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterInsert, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CoreConfigurations) DBUpsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CoreConfigurationsUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CoreConfigurations can't be nil")
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagBeforeUpsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CoreConfigurationUpsertByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCoreConfigurationFunc(ctx, dml.EventFlagAfterUpsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// Delete will remove an item from the slice. Auto generated via dmlgen.
func (cc *CoreConfigurations) Delete(i int) *CoreConfigurations {
	z := cc.Data // copy the slice header
	end := len(z) - 1
	cc.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = nil // this should avoid the memory leak
	z = z[:end]
	cc.Data = z
	return cc
}

// Each will run function f on all items in []* CoreConfiguration . Auto
// generated via dmlgen.
func (cc *CoreConfigurations) Each(f func(*CoreConfiguration)) *CoreConfigurations {
	if cc == nil {
		return nil
	}
	for i := range cc.Data {
		f(cc.Data[i])
	}
	return cc
}

// Filter filters the current slice by predicate f without memory allocation.
// Auto generated via dmlgen.
func (cc *CoreConfigurations) Filter(f func(*CoreConfiguration) bool) *CoreConfigurations {
	if cc == nil {
		return nil
	}
	b, i := cc.Data[:0], 0
	for _, e := range cc.Data {
		if f(e) {
			b = append(b, e)
		}
		i++
	}
	for i := len(b); i < len(cc.Data); i++ {
		cc.Data[i] = nil // this should avoid the memory leak
	}
	cc.Data = b
	return cc
}

// Insert will place a new item at position i. Auto generated via dmlgen.
func (cc *CoreConfigurations) Insert(n *CoreConfiguration, i int) *CoreConfigurations {
	z := cc.Data // copy the slice header
	z = append(z, &CoreConfiguration{})
	copy(z[i+1:], z[i:])
	z[i] = n
	cc.Data = z
	return cc
}

// Swap will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CoreConfigurations) Swap(i, j int) { cc.Data[i], cc.Data[j] = cc.Data[j], cc.Data[i] }

// Len will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CoreConfigurations) Len() int {
	if cc == nil {
		return 0
	}
	return len(cc.Data)
}

// ConfigIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CoreConfigurations) ConfigIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ConfigID)
	}
	return ret
}

// Paths belongs to the column "path" and returns a slice or appends to a slice
// only unique values of that column. The values will be filtered internally in a
// Go map. No DB query gets executed. Auto generated.
func (cc *CoreConfigurations) UniquePaths(ret ...string) []string {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]string, 0, len(cc.Data))
	}
	dupCheck := make(map[string]bool, len(cc.Data))
	for _, e := range cc.Data {
		if !dupCheck[e.Path] {
			ret = append(ret, e.Path)
			dupCheck[e.Path] = true
		}
	}
	return ret
}

// Validate runs internal consistency tests on all items.
func (cc *CoreConfigurations) Validate() (err error) {
	if len(cc.Data) == 0 {
		return nil
	}
	for i, ld := 0, len(cc.Data); i < ld && err == nil; i++ {
		err = cc.Data[i].Validate()
	}
	return
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (cc *CoreConfigurations) WriteTo(w io.Writer) (n int64, err error) {
	for i, d := range cc.Data {
		n2, err := d.WriteTo(w)
		if err != nil {
			return 0, errors.Wrapf(err, "[dmltestgenerated] WriteTo failed at index %d", i)
		}
		n += n2
	}
	return n, nil
}

// CustomerAddressEntity represents a single row for DB table
// customer_address_entity. Auto generated.
// Table comment: Customer Address Entity
//easyjson:json
type CustomerAddressEntity struct {
	EntityID          uint32      `max_len:"10"` // entity_id int(10) unsigned NOT NULL PRI  auto_increment "Entity ID"
	IncrementID       null.String `max_len:"50"` // increment_id varchar(50) NULL  DEFAULT 'NULL'  "Increment Id"
	ParentID          null.Uint32 `max_len:"10"` // parent_id int(10) unsigned NULL MUL DEFAULT 'NULL'  "Parent ID"
	CreatedAt         time.Time   // created_at timestamp NOT NULL  DEFAULT 'current_timestamp()'  "Created At"
	UpdatedAt         time.Time   // updated_at timestamp NOT NULL  DEFAULT 'current_timestamp()' on update current_timestamp() "Updated At"
	IsActive          bool        `max_len:"5"`     // is_active smallint(5) unsigned NOT NULL  DEFAULT '1'  "Is Active"
	City              string      `max_len:"255"`   // city varchar(255) NOT NULL    "City"
	Company           null.String `max_len:"255"`   // company varchar(255) NULL  DEFAULT 'NULL'  "Company"
	CountryID         string      `max_len:"255"`   // country_id varchar(255) NOT NULL    "Country"
	Fax               null.String `max_len:"255"`   // fax varchar(255) NULL  DEFAULT 'NULL'  "Fax"
	Firstname         string      `max_len:"255"`   // firstname varchar(255) NOT NULL    "First Name"
	Lastname          string      `max_len:"255"`   // lastname varchar(255) NOT NULL    "Last Name"
	Middlename        null.String `max_len:"255"`   // middlename varchar(255) NULL  DEFAULT 'NULL'  "Middle Name"
	Postcode          null.String `max_len:"255"`   // postcode varchar(255) NULL  DEFAULT 'NULL'  "Zip/Postal Code"
	Prefix            null.String `max_len:"40"`    // prefix varchar(40) NULL  DEFAULT 'NULL'  "Name Prefix"
	Region            null.String `max_len:"255"`   // region varchar(255) NULL  DEFAULT 'NULL'  "State/Province"
	RegionID          null.Uint32 `max_len:"10"`    // region_id int(10) unsigned NULL  DEFAULT 'NULL'  "State/Province"
	Street            string      `max_len:"65535"` // street text NOT NULL    "Street Address"
	Suffix            null.String `max_len:"40"`    // suffix varchar(40) NULL  DEFAULT 'NULL'  "Name Suffix"
	Telephone         string      `max_len:"255"`   // telephone varchar(255) NOT NULL    "Phone Number"
	VatID             null.String `max_len:"255"`   // vat_id varchar(255) NULL  DEFAULT 'NULL'  "VAT number"
	VatIsValid        null.Bool   `max_len:"10"`    // vat_is_valid int(10) unsigned NULL  DEFAULT 'NULL'  "VAT number validity"
	VatRequestDate    null.String `max_len:"255"`   // vat_request_date varchar(255) NULL  DEFAULT 'NULL'  "VAT number validation request date"
	VatRequestID      null.String `max_len:"255"`   // vat_request_id varchar(255) NULL  DEFAULT 'NULL'  "VAT number validation request ID"
	VatRequestSuccess null.Uint32 `max_len:"10"`    // vat_request_success int(10) unsigned NULL  DEFAULT 'NULL'  "VAT number validation request success"
}

// Copy copies the struct and returns a new pointer. TODO use deepcopy tool to
// generate code afterwards
func (e *CustomerAddressEntity) Copy() *CustomerAddressEntity {
	e2 := new(CustomerAddressEntity)
	*e2 = *e // for now a shallow copy
	return e2
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerAddressEntity) AssignLastInsertID(id int64) {
	e.EntityID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerAddressEntity) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint32(&e.EntityID).NullString(&e.IncrementID).NullUint32(&e.ParentID).Time(&e.CreatedAt).Time(&e.UpdatedAt).Bool(&e.IsActive).String(&e.City).NullString(&e.Company).String(&e.CountryID).NullString(&e.Fax).String(&e.Firstname).String(&e.Lastname).NullString(&e.Middlename).NullString(&e.Postcode).NullString(&e.Prefix).NullString(&e.Region).NullUint32(&e.RegionID).String(&e.Street).NullString(&e.Suffix).String(&e.Telephone).NullString(&e.VatID).NullBool(&e.VatIsValid).NullString(&e.VatRequestDate).NullString(&e.VatRequestID).NullUint32(&e.VatRequestSuccess).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "entity_id":
			cm.Uint32(&e.EntityID)
		case "increment_id":
			cm.NullString(&e.IncrementID)
		case "parent_id":
			cm.NullUint32(&e.ParentID)
		case "created_at":
			cm.Time(&e.CreatedAt)
		case "updated_at":
			cm.Time(&e.UpdatedAt)
		case "is_active":
			cm.Bool(&e.IsActive)
		case "city":
			cm.String(&e.City)
		case "company":
			cm.NullString(&e.Company)
		case "country_id":
			cm.String(&e.CountryID)
		case "fax":
			cm.NullString(&e.Fax)
		case "firstname":
			cm.String(&e.Firstname)
		case "lastname":
			cm.String(&e.Lastname)
		case "middlename":
			cm.NullString(&e.Middlename)
		case "postcode":
			cm.NullString(&e.Postcode)
		case "prefix":
			cm.NullString(&e.Prefix)
		case "region":
			cm.NullString(&e.Region)
		case "region_id":
			cm.NullUint32(&e.RegionID)
		case "street":
			cm.String(&e.Street)
		case "suffix":
			cm.NullString(&e.Suffix)
		case "telephone":
			cm.String(&e.Telephone)
		case "vat_id":
			cm.NullString(&e.VatID)
		case "vat_is_valid":
			cm.NullBool(&e.VatIsValid)
		case "vat_request_date":
			cm.NullString(&e.VatRequestDate)
		case "vat_request_id":
			cm.NullString(&e.VatRequestID)
		case "vat_request_success":
			cm.NullUint32(&e.VatRequestSuccess)
		default:
			return errors.NotFound.Newf("[dmltestgenerated] CustomerAddressEntity Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

func (e *CustomerAddressEntity) Load(ctx context.Context, dbm *DBM, primaryKey uint32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntitySelectByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	// put the IDs primaryKey into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeSelect, nil, e); err != nil {
		return errors.WithStack(err)
	}
	if e.IsSet() {
		return nil // might return data from cache
	}
	if _, err = dbm.CachedQuery("CustomerAddressEntitySelectByPK").ApplyCallBacks(opts...).Load(ctx, e, primaryKey); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterSelect, nil, e))
}

func (e *CustomerAddressEntity) Delete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntityDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeDelete, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerAddressEntityDeleteByPK").ApplyCallBacks(opts...).ExecContext(ctx, e.EntityID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterDelete, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerAddressEntity) Update(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntityUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeUpdate, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerAddressEntityUpdateByPK").ApplyCallBacks(opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterUpdate, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerAddressEntity) Insert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntityInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeInsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerAddressEntityInsert").ApplyCallBacks(opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterInsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerAddressEntity) Upsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntityUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeUpsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerAddressEntityUpsertByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", e)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterUpsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// Empty empties all the fields of the current object. Also known as Reset.
func (e *CustomerAddressEntity) Empty() *CustomerAddressEntity {
	*e = CustomerAddressEntity{}
	return e
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *CustomerAddressEntity) IsSet() bool { return e.EntityID > 0 }

// This variable can be set in another file to provide a custom validator.
var validateCustomerAddressEntity func(*CustomerAddressEntity) error

// Validate runs internal consistency tests.
func (e *CustomerAddressEntity) Validate() error {
	if e == nil {
		return errors.NotValid.Newf("Type %T cannot be nil", e)
	}
	if validateCustomerAddressEntity != nil {
		return validateCustomerAddressEntity(e)
	}
	return nil
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (e *CustomerAddressEntity) WriteTo(w io.Writer) (n int64, err error) {
	// for now this printing is good enough. If you need better swap out with your code.
	n2, err := fmt.Fprint(w,
		"entity_id:", e.EntityID, "\n",
		"increment_id:", e.IncrementID, "\n",
		"parent_id:", e.ParentID, "\n",
		"created_at:", e.CreatedAt, "\n",
		"updated_at:", e.UpdatedAt, "\n",
		"is_active:", e.IsActive, "\n",
		"city:", e.City, "\n",
		"company:", e.Company, "\n",
		"country_id:", e.CountryID, "\n",
		"fax:", e.Fax, "\n",
		"firstname:", e.Firstname, "\n",
		"lastname:", e.Lastname, "\n",
		"middlename:", e.Middlename, "\n",
		"postcode:", e.Postcode, "\n",
		"prefix:", e.Prefix, "\n",
		"region:", e.Region, "\n",
		"region_id:", e.RegionID, "\n",
		"street:", e.Street, "\n",
		"suffix:", e.Suffix, "\n",
		"telephone:", e.Telephone, "\n",
		"vat_id:", e.VatID, "\n",
		"vat_is_valid:", e.VatIsValid, "\n",
		"vat_request_date:", e.VatRequestDate, "\n",
		"vat_request_id:", e.VatRequestID, "\n",
		"vat_request_success:", e.VatRequestSuccess, "\n",
	)
	return int64(n2), err
}

// CustomerAddressEntities represents a collection type for DB table
// customer_address_entity
// Not thread safe. Auto generated.
//easyjson:json
type CustomerAddressEntities struct {
	Data []*CustomerAddressEntity `json:"data,omitempty"`
}

// NewCustomerAddressEntities  creates a new initialized collection. Auto
// generated.
func NewCustomerAddressEntities() *CustomerAddressEntities {
	return &CustomerAddressEntities{
		Data: make([]*CustomerAddressEntity, 0, 5),
	}
}

// Append will add a new item at the end of * CustomerAddressEntities . Auto
// generated via dmlgen.
func (cc *CustomerAddressEntities) Append(n ...*CustomerAddressEntity) *CustomerAddressEntities {
	cc.Data = append(cc.Data, n...)
	return cc
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (cc *CustomerAddressEntities) UnmarshalBinary(data []byte) error {
	return cc.Unmarshal(data) // Implemented via github.com/gogo/protobuf
}

// MarshalBinary implements encoding.BinaryMarshaler.
func (cc *CustomerAddressEntities) MarshalBinary() (data []byte, err error) {
	return cc.Marshal() // Implemented via github.com/gogo/protobuf
}

// Cut will remove items i through j-1. Auto generated via dmlgen.
func (cc *CustomerAddressEntities) Cut(i, j int) *CustomerAddressEntities {
	z := cc.Data // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k] = nil // this avoids the memory leak
	}
	z = z[:len(z)-j+i]
	cc.Data = z
	return cc
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CustomerAddressEntities) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CustomerAddressEntities) scanColumns(cm *dml.ColumnMap, e *CustomerAddressEntity) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CustomerAddressEntities) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		var e CustomerAddressEntity
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "entity_id":
				cm = cm.Uint32s(cc.EntityIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated] CustomerAddressEntities Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgenerated] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

func (cc *CustomerAddressEntities) DBLoad(ctx context.Context, dbm *DBM, pkIDs []uint32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntitiesDBLoad")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerAddressEntity can't be nil")
	}
	// put the IDs EntityID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeSelect, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if cc.Data != nil {
		return nil // might return data from cache
	}
	if len(pkIDs) > 0 {
		if _, err = dbm.CachedQuery("CustomerAddressEntitiesSelectByPK").ApplyCallBacks(opts...).Load(ctx, cc, pkIDs); err != nil {
			return errors.WithStack(err)
		}
	} else {
		if _, err = dbm.CachedQuery("CustomerAddressEntitiesSelectAll").ApplyCallBacks(opts...).Load(ctx, cc); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterSelect, cc, nil))
}

func (cc *CustomerAddressEntities) DBDelete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntitiesDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntities can't be nil")
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeDelete, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerAddressEntityDeleteByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterDelete, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CustomerAddressEntities) DBUpdate(ctx context.Context, dbm *DBM, resCheckFn func(sql.Result, error) error, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntitiesUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerAddressEntities can't be nil")
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeUpdate, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if len(opts) == 0 {
		opts = dbmEmptyOpts
	}
	if resCheckFn == nil {
		resCheckFn = dbmNoopResultCheckFn
	}
	dbrStmt, err := dbm.CachedQuery("CustomerAddressEntityUpdateByPK").ApplyCallBacks(opts...).Prepare(ctx)
	if err != nil {
		return errors.WithStack(err)
	}
	for _, c := range cc.Data {
		if err := resCheckFn(dbrStmt.ExecContext(ctx, c)); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterUpdate, cc, nil))
}

func (cc *CustomerAddressEntities) DBInsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntitiesInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntities can't be nil")
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeInsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerAddressEntityInsert").ApplyCallBacks(opts...).ExecContext(ctx, cc); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterInsert, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CustomerAddressEntities) DBUpsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerAddressEntitiesUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerAddressEntities can't be nil")
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagBeforeUpsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerAddressEntityUpsertByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerAddressEntityFunc(ctx, dml.EventFlagAfterUpsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// Delete will remove an item from the slice. Auto generated via dmlgen.
func (cc *CustomerAddressEntities) Delete(i int) *CustomerAddressEntities {
	z := cc.Data // copy the slice header
	end := len(z) - 1
	cc.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = nil // this should avoid the memory leak
	z = z[:end]
	cc.Data = z
	return cc
}

// Each will run function f on all items in []* CustomerAddressEntity . Auto
// generated via dmlgen.
func (cc *CustomerAddressEntities) Each(f func(*CustomerAddressEntity)) *CustomerAddressEntities {
	if cc == nil {
		return nil
	}
	for i := range cc.Data {
		f(cc.Data[i])
	}
	return cc
}

// Filter filters the current slice by predicate f without memory allocation.
// Auto generated via dmlgen.
func (cc *CustomerAddressEntities) Filter(f func(*CustomerAddressEntity) bool) *CustomerAddressEntities {
	if cc == nil {
		return nil
	}
	b, i := cc.Data[:0], 0
	for _, e := range cc.Data {
		if f(e) {
			b = append(b, e)
		}
		i++
	}
	for i := len(b); i < len(cc.Data); i++ {
		cc.Data[i] = nil // this should avoid the memory leak
	}
	cc.Data = b
	return cc
}

// Insert will place a new item at position i. Auto generated via dmlgen.
func (cc *CustomerAddressEntities) Insert(n *CustomerAddressEntity, i int) *CustomerAddressEntities {
	z := cc.Data // copy the slice header
	z = append(z, &CustomerAddressEntity{})
	copy(z[i+1:], z[i:])
	z[i] = n
	cc.Data = z
	return cc
}

// Swap will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CustomerAddressEntities) Swap(i, j int) { cc.Data[i], cc.Data[j] = cc.Data[j], cc.Data[i] }

// Len will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CustomerAddressEntities) Len() int {
	if cc == nil {
		return 0
	}
	return len(cc.Data)
}

// EntityIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CustomerAddressEntities) EntityIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.EntityID)
	}
	return ret
}

// Validate runs internal consistency tests on all items.
func (cc *CustomerAddressEntities) Validate() (err error) {
	if len(cc.Data) == 0 {
		return nil
	}
	for i, ld := 0, len(cc.Data); i < ld && err == nil; i++ {
		err = cc.Data[i].Validate()
	}
	return
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (cc *CustomerAddressEntities) WriteTo(w io.Writer) (n int64, err error) {
	for i, d := range cc.Data {
		n2, err := d.WriteTo(w)
		if err != nil {
			return 0, errors.Wrapf(err, "[dmltestgenerated] WriteTo failed at index %d", i)
		}
		n += n2
	}
	return n, nil
}

// CustomerEntity represents a single row for DB table customer_entity. Auto
// generated.
// Table comment: Customer Entity
//easyjson:json
type CustomerEntity struct {
	EntityID                uint32                   `max_len:"10"`  // entity_id int(10) unsigned NOT NULL PRI  auto_increment "Entity ID"
	WebsiteID               null.Uint32              `max_len:"5"`   // website_id smallint(5) unsigned NULL MUL DEFAULT 'NULL'  "Website ID"
	Email                   null.String              `max_len:"255"` // email varchar(255) NULL MUL DEFAULT 'NULL'  "Email"
	GroupID                 uint32                   `max_len:"5"`   // group_id smallint(5) unsigned NOT NULL  DEFAULT '0'  "Group ID"
	IncrementID             null.String              `max_len:"50"`  // increment_id varchar(50) NULL  DEFAULT 'NULL'  "Increment Id"
	StoreID                 null.Uint32              `max_len:"5"`   // store_id smallint(5) unsigned NULL MUL DEFAULT '0'  "Store ID"
	CreatedAt               time.Time                // created_at timestamp NOT NULL  DEFAULT 'current_timestamp()'  "Created At"
	UpdatedAt               time.Time                // updated_at timestamp NOT NULL  DEFAULT 'current_timestamp()' on update current_timestamp() "Updated At"
	IsActive                bool                     `max_len:"5"`   // is_active smallint(5) unsigned NOT NULL  DEFAULT '1'  "Is Active"
	DisableAutoGroupChange  uint32                   `max_len:"5"`   // disable_auto_group_change smallint(5) unsigned NOT NULL  DEFAULT '0'  "Disable automatic group change based on VAT ID"
	CreatedIn               null.String              `max_len:"255"` // created_in varchar(255) NULL  DEFAULT 'NULL'  "Created From"
	Prefix                  null.String              `max_len:"40"`  // prefix varchar(40) NULL  DEFAULT 'NULL'  "Name Prefix"
	Firstname               null.String              `max_len:"255"` // firstname varchar(255) NULL MUL DEFAULT 'NULL'  "First Name"
	Middlename              null.String              `max_len:"255"` // middlename varchar(255) NULL  DEFAULT 'NULL'  "Middle Name/Initial"
	Lastname                null.String              `max_len:"255"` // lastname varchar(255) NULL MUL DEFAULT 'NULL'  "Last Name"
	Suffix                  null.String              `max_len:"40"`  // suffix varchar(40) NULL  DEFAULT 'NULL'  "Name Suffix"
	Dob                     null.Time                // dob date NULL  DEFAULT 'NULL'  "Date of Birth"
	passwordHash            null.String              `max_len:"128"` // password_hash varchar(128) NULL  DEFAULT 'NULL'  "Password_hash"
	RpToken                 null.String              `max_len:"128"` // rp_token varchar(128) NULL  DEFAULT 'NULL'  "Reset password token"
	RpTokenCreatedAt        null.Time                // rp_token_created_at datetime NULL  DEFAULT 'NULL'  "Reset password token creation time"
	DefaultBilling          null.Uint32              `max_len:"10"` // default_billing int(10) unsigned NULL  DEFAULT 'NULL'  "Default Billing Address"
	DefaultShipping         null.Uint32              `max_len:"10"` // default_shipping int(10) unsigned NULL  DEFAULT 'NULL'  "Default Shipping Address"
	Taxvat                  null.String              `max_len:"50"` // taxvat varchar(50) NULL  DEFAULT 'NULL'  "Tax/VAT Number"
	Confirmation            null.String              `max_len:"64"` // confirmation varchar(64) NULL  DEFAULT 'NULL'  "Is Confirmed"
	Gender                  null.Uint32              `max_len:"5"`  // gender smallint(5) unsigned NULL  DEFAULT 'NULL'  "Gender"
	FailuresNum             null.Int32               `max_len:"5"`  // failures_num smallint(6) NULL  DEFAULT '0'  "Failure Number"
	FirstFailure            null.Time                // first_failure timestamp NULL  DEFAULT 'NULL'  "First Failure"
	LockExpires             null.Time                // lock_expires timestamp NULL  DEFAULT 'NULL'  "Lock Expiration Date"
	CustomerAddressEntities *CustomerAddressEntities // Reversed 1:M customer_entity.entity_id => customer_address_entity.parent_id
}

// Copy copies the struct and returns a new pointer. TODO use deepcopy tool to
// generate code afterwards
func (e *CustomerEntity) Copy() *CustomerEntity {
	e2 := new(CustomerEntity)
	*e2 = *e // for now a shallow copy
	return e2
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerEntity) AssignLastInsertID(id int64) {
	e.EntityID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerEntity) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint32(&e.EntityID).NullUint32(&e.WebsiteID).NullString(&e.Email).Uint32(&e.GroupID).NullString(&e.IncrementID).NullUint32(&e.StoreID).Time(&e.CreatedAt).Time(&e.UpdatedAt).Bool(&e.IsActive).Uint32(&e.DisableAutoGroupChange).NullString(&e.CreatedIn).NullString(&e.Prefix).NullString(&e.Firstname).NullString(&e.Middlename).NullString(&e.Lastname).NullString(&e.Suffix).NullTime(&e.Dob).NullString(&e.passwordHash).NullString(&e.RpToken).NullTime(&e.RpTokenCreatedAt).NullUint32(&e.DefaultBilling).NullUint32(&e.DefaultShipping).NullString(&e.Taxvat).NullString(&e.Confirmation).NullUint32(&e.Gender).NullInt32(&e.FailuresNum).NullTime(&e.FirstFailure).NullTime(&e.LockExpires).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "entity_id":
			cm.Uint32(&e.EntityID)
		case "website_id":
			cm.NullUint32(&e.WebsiteID)
		case "email":
			cm.NullString(&e.Email)
		case "group_id":
			cm.Uint32(&e.GroupID)
		case "increment_id":
			cm.NullString(&e.IncrementID)
		case "store_id":
			cm.NullUint32(&e.StoreID)
		case "created_at":
			cm.Time(&e.CreatedAt)
		case "updated_at":
			cm.Time(&e.UpdatedAt)
		case "is_active":
			cm.Bool(&e.IsActive)
		case "disable_auto_group_change":
			cm.Uint32(&e.DisableAutoGroupChange)
		case "created_in":
			cm.NullString(&e.CreatedIn)
		case "prefix":
			cm.NullString(&e.Prefix)
		case "firstname":
			cm.NullString(&e.Firstname)
		case "middlename":
			cm.NullString(&e.Middlename)
		case "lastname":
			cm.NullString(&e.Lastname)
		case "suffix":
			cm.NullString(&e.Suffix)
		case "dob":
			cm.NullTime(&e.Dob)
		case "password_hash":
			cm.NullString(&e.passwordHash)
		case "rp_token":
			cm.NullString(&e.RpToken)
		case "rp_token_created_at":
			cm.NullTime(&e.RpTokenCreatedAt)
		case "default_billing":
			cm.NullUint32(&e.DefaultBilling)
		case "default_shipping":
			cm.NullUint32(&e.DefaultShipping)
		case "taxvat":
			cm.NullString(&e.Taxvat)
		case "confirmation":
			cm.NullString(&e.Confirmation)
		case "gender":
			cm.NullUint32(&e.Gender)
		case "failures_num":
			cm.NullInt32(&e.FailuresNum)
		case "first_failure":
			cm.NullTime(&e.FirstFailure)
		case "lock_expires":
			cm.NullTime(&e.LockExpires)
		default:
			return errors.NotFound.Newf("[dmltestgenerated] CustomerEntity Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

func (e *CustomerEntity) Load(ctx context.Context, dbm *DBM, primaryKey uint32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntitySelectByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	// put the IDs primaryKey into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeSelect, nil, e); err != nil {
		return errors.WithStack(err)
	}
	if e.IsSet() {
		return nil // might return data from cache
	}
	if _, err = dbm.CachedQuery("CustomerEntitySelectByPK").ApplyCallBacks(opts...).Load(ctx, e, primaryKey); err != nil {
		return errors.WithStack(err)
	}
	return errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterSelect, nil, e))
}

func (e *CustomerEntity) Delete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeDelete, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerEntityDeleteByPK").ApplyCallBacks(opts...).ExecContext(ctx, e.EntityID); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterDelete, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntity) Update(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeUpdate, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerEntityUpdateByPK").ApplyCallBacks(opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterUpdate, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntity) Insert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeInsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerEntityInsert").ApplyCallBacks(opts...).ExecContext(ctx, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterInsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (e *CustomerEntity) Upsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntityUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if e == nil {
		return nil, errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeUpsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerEntityUpsertByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", e)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterUpsert, nil, e); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// Empty empties all the fields of the current object. Also known as Reset.
func (e *CustomerEntity) Empty() *CustomerEntity { *e = CustomerEntity{}; return e }

// IsSet returns true if the entity has non-empty primary keys.
func (e *CustomerEntity) IsSet() bool { return e.EntityID > 0 }

// Set PasswordHash  sets the data for a private and security sensitive field.
func (e *CustomerEntity) SetPasswordHash(d null.String) *CustomerEntity {
	e.passwordHash = d
	return e
}

// Get PasswordHash  returns the data from a private and security sensitive
// field.
func (e *CustomerEntity) GetPasswordHash() null.String {
	return e.passwordHash
}

// This variable can be set in another file to provide a custom validator.
var validateCustomerEntity func(*CustomerEntity) error

// Validate runs internal consistency tests.
func (e *CustomerEntity) Validate() error {
	if e == nil {
		return errors.NotValid.Newf("Type %T cannot be nil", e)
	}
	if validateCustomerEntity != nil {
		return validateCustomerEntity(e)
	}
	return nil
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (e *CustomerEntity) WriteTo(w io.Writer) (n int64, err error) {
	// for now this printing is good enough. If you need better swap out with your code.
	n2, err := fmt.Fprint(w,
		"entity_id:", e.EntityID, "\n",
		"website_id:", e.WebsiteID, "\n",
		"email:", e.Email, "\n",
		"group_id:", e.GroupID, "\n",
		"increment_id:", e.IncrementID, "\n",
		"store_id:", e.StoreID, "\n",
		"created_at:", e.CreatedAt, "\n",
		"updated_at:", e.UpdatedAt, "\n",
		"is_active:", e.IsActive, "\n",
		"disable_auto_group_change:", e.DisableAutoGroupChange, "\n",
		"created_in:", e.CreatedIn, "\n",
		"prefix:", e.Prefix, "\n",
		"firstname:", e.Firstname, "\n",
		"middlename:", e.Middlename, "\n",
		"lastname:", e.Lastname, "\n",
		"suffix:", e.Suffix, "\n",
		"dob:", e.Dob, "\n",
		"rp_token:", e.RpToken, "\n",
		"rp_token_created_at:", e.RpTokenCreatedAt, "\n",
		"default_billing:", e.DefaultBilling, "\n",
		"default_shipping:", e.DefaultShipping, "\n",
		"taxvat:", e.Taxvat, "\n",
		"confirmation:", e.Confirmation, "\n",
		"gender:", e.Gender, "\n",
		"failures_num:", e.FailuresNum, "\n",
		"first_failure:", e.FirstFailure, "\n",
		"lock_expires:", e.LockExpires, "\n",
	)
	return int64(n2), err
}

// CustomerEntities represents a collection type for DB table customer_entity
// Not thread safe. Auto generated.
//easyjson:json
type CustomerEntities struct {
	Data []*CustomerEntity `json:"data,omitempty"`
}

// NewCustomerEntities  creates a new initialized collection. Auto generated.
func NewCustomerEntities() *CustomerEntities {
	return &CustomerEntities{
		Data: make([]*CustomerEntity, 0, 5),
	}
}

// Append will add a new item at the end of * CustomerEntities . Auto generated
// via dmlgen.
func (cc *CustomerEntities) Append(n ...*CustomerEntity) *CustomerEntities {
	cc.Data = append(cc.Data, n...)
	return cc
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (cc *CustomerEntities) UnmarshalBinary(data []byte) error {
	return cc.Unmarshal(data) // Implemented via github.com/gogo/protobuf
}

// MarshalBinary implements encoding.BinaryMarshaler.
func (cc *CustomerEntities) MarshalBinary() (data []byte, err error) {
	return cc.Marshal() // Implemented via github.com/gogo/protobuf
}

// Cut will remove items i through j-1. Auto generated via dmlgen.
func (cc *CustomerEntities) Cut(i, j int) *CustomerEntities {
	z := cc.Data // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k] = nil // this avoids the memory leak
	}
	z = z[:len(z)-j+i]
	cc.Data = z
	return cc
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CustomerEntities) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CustomerEntities) scanColumns(cm *dml.ColumnMap, e *CustomerEntity) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CustomerEntities) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		var e CustomerEntity
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "entity_id":
				cm = cm.Uint32s(cc.EntityIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgenerated] CustomerEntities Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgenerated] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

func (cc *CustomerEntities) DBLoad(ctx context.Context, dbm *DBM, pkIDs []uint32, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntitiesDBLoad")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntity can't be nil")
	}
	// put the IDs EntityID into the context as value to search for a cache entry in the event function.
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeSelect, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if cc.Data != nil {
		return nil // might return data from cache
	}
	if len(pkIDs) > 0 {
		if _, err = dbm.CachedQuery("CustomerEntitiesSelectByPK").ApplyCallBacks(opts...).Load(ctx, cc, pkIDs); err != nil {
			return errors.WithStack(err)
		}
	} else {
		if _, err = dbm.CachedQuery("CustomerEntitiesSelectAll").ApplyCallBacks(opts...).Load(ctx, cc); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterSelect, cc, nil))
}

func (cc *CustomerEntities) DBDelete(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntitiesDeleteByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerEntities can't be nil")
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeDelete, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerEntityDeleteByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterDelete, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CustomerEntities) DBUpdate(ctx context.Context, dbm *DBM, resCheckFn func(sql.Result, error) error, opts ...dml.DBRFunc) (err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntitiesUpdateByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return errors.NotValid.Newf("CustomerEntities can't be nil")
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeUpdate, cc, nil); err != nil {
		return errors.WithStack(err)
	}
	if len(opts) == 0 {
		opts = dbmEmptyOpts
	}
	if resCheckFn == nil {
		resCheckFn = dbmNoopResultCheckFn
	}
	dbrStmt, err := dbm.CachedQuery("CustomerEntityUpdateByPK").ApplyCallBacks(opts...).Prepare(ctx)
	if err != nil {
		return errors.WithStack(err)
	}
	for _, c := range cc.Data {
		if err := resCheckFn(dbrStmt.ExecContext(ctx, c)); err != nil {
			return errors.WithStack(err)
		}
	}
	return errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterUpdate, cc, nil))
}

func (cc *CustomerEntities) DBInsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntitiesInsert")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerEntities can't be nil")
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeInsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerEntityInsert").ApplyCallBacks(opts...).ExecContext(ctx, cc); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = errors.WithStack(dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterInsert, cc, nil)); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

func (cc *CustomerEntities) DBUpsert(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (res sql.Result, err error) {
	ctx, span := dbm.option.Trace.Start(ctx, "CustomerEntitiesUpsertByPK")
	defer func() { cstrace.Status(span, err, ""); span.End() }()
	if cc == nil {
		return nil, errors.NotValid.Newf("CustomerEntities can't be nil")
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagBeforeUpsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	if res, err = dbm.CachedQuery("CustomerEntityUpsertByPK").ApplyCallBacks(opts...).ExecContext(ctx, dml.Qualify("", cc)); err != nil {
		return nil, errors.WithStack(err)
	}
	if err = dbm.eventCustomerEntityFunc(ctx, dml.EventFlagAfterUpsert, cc, nil); err != nil {
		return nil, errors.WithStack(err)
	}
	return res, nil
}

// Delete will remove an item from the slice. Auto generated via dmlgen.
func (cc *CustomerEntities) Delete(i int) *CustomerEntities {
	z := cc.Data // copy the slice header
	end := len(z) - 1
	cc.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = nil // this should avoid the memory leak
	z = z[:end]
	cc.Data = z
	return cc
}

// Each will run function f on all items in []* CustomerEntity . Auto generated
// via dmlgen.
func (cc *CustomerEntities) Each(f func(*CustomerEntity)) *CustomerEntities {
	if cc == nil {
		return nil
	}
	for i := range cc.Data {
		f(cc.Data[i])
	}
	return cc
}

// Filter filters the current slice by predicate f without memory allocation.
// Auto generated via dmlgen.
func (cc *CustomerEntities) Filter(f func(*CustomerEntity) bool) *CustomerEntities {
	if cc == nil {
		return nil
	}
	b, i := cc.Data[:0], 0
	for _, e := range cc.Data {
		if f(e) {
			b = append(b, e)
		}
		i++
	}
	for i := len(b); i < len(cc.Data); i++ {
		cc.Data[i] = nil // this should avoid the memory leak
	}
	cc.Data = b
	return cc
}

// Insert will place a new item at position i. Auto generated via dmlgen.
func (cc *CustomerEntities) Insert(n *CustomerEntity, i int) *CustomerEntities {
	z := cc.Data // copy the slice header
	z = append(z, &CustomerEntity{})
	copy(z[i+1:], z[i:])
	z[i] = n
	cc.Data = z
	return cc
}

// Swap will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CustomerEntities) Swap(i, j int) { cc.Data[i], cc.Data[j] = cc.Data[j], cc.Data[i] }

// Len will satisfy the sort.Interface. Auto generated via dmlgen.
func (cc *CustomerEntities) Len() int {
	if cc == nil {
		return 0
	}
	return len(cc.Data)
}

// EntityIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CustomerEntities) EntityIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.EntityID)
	}
	return ret
}

// Validate runs internal consistency tests on all items.
func (cc *CustomerEntities) Validate() (err error) {
	if len(cc.Data) == 0 {
		return nil
	}
	for i, ld := 0, len(cc.Data); i < ld && err == nil; i++ {
		err = cc.Data[i].Validate()
	}
	return
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (cc *CustomerEntities) WriteTo(w io.Writer) (n int64, err error) {
	for i, d := range cc.Data {
		n2, err := d.WriteTo(w)
		if err != nil {
			return 0, errors.Wrapf(err, "[dmltestgenerated] WriteTo failed at index %d", i)
		}
		n += n2
	}
	return n, nil
}
