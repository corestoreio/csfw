// +build csall db

// Auto generated via github.com/corestoreio/pkg/sql/dmlgen

package storage

import (
	"context"
	"github.com/corestoreio/errors"
	"github.com/corestoreio/pkg/sql/ddl"
	"github.com/corestoreio/pkg/sql/dml"
	"github.com/corestoreio/pkg/storage/null"
	"time"
)

const (
	TableNameCoreConfigData = "core_config_data"
)

// NewTables returns a goified version of the MySQL/MariaDB table schema for the
// tables: [core_config_data]
// Auto generated by dmlgen.
func NewTables(ctx context.Context, opts ...ddl.TableOption) (tm *ddl.Tables, err error) {
	if tm, err = ddl.NewTables(
		append(opts,
			ddl.WithCreateTable(ctx,
				TableNameCoreConfigData, ""),
		)...,
	); err != nil {
		return nil, errors.WithStack(err)
	}
	return tm, nil
}

// CoreConfigData represents a single row for DB table `core_config_data`.
// Auto generated.
type CoreConfigData struct {
	ConfigID  uint32      `max_len:"10"` // config_id int(10) unsigned NOT NULL PRI  auto_increment "Id"
	Scope     string      `max_len:"8"`  // scope varchar(8) NOT NULL MUL DEFAULT ''default''  "Scope"
	ScopeID   int32       `max_len:"10"` // scope_id int(11) NOT NULL  DEFAULT '0'  "Scope Id"
	Expires   null.Time   // expires datetime NULL  DEFAULT 'NULL'  "Value expiration time"
	Path      string      `max_len:"255"`   // path varchar(255) NOT NULL    "Path"
	Value     null.String `max_len:"65535"` // value text NULL  DEFAULT 'NULL'  "Value"
	VersionTs time.Time   // version_ts timestamp(6) NOT NULL    "Timestamp Start Versioning"
	VersionTe time.Time   // version_te timestamp(6) NOT NULL PRI   "Timestamp End Versioning"
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CoreConfigData) AssignLastInsertID(id int64) {
	e.ConfigID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CoreConfigData) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint32(&e.ConfigID).String(&e.Scope).Int32(&e.ScopeID).NullTime(&e.Expires).String(&e.Path).NullString(&e.Value).Time(&e.VersionTs).Time(&e.VersionTe).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "config_id":
			cm.Uint32(&e.ConfigID)
		case "scope":
			cm.String(&e.Scope)
		case "scope_id":
			cm.Int32(&e.ScopeID)
		case "expires":
			cm.NullTime(&e.Expires)
		case "path":
			cm.String(&e.Path)
		case "value":
			cm.NullString(&e.Value)
		case "version_ts":
			cm.Time(&e.VersionTs)
		case "version_te":
			cm.Time(&e.VersionTe)
		default:
			return errors.NotFound.Newf("[storage] CoreConfigData Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// Empty empties all the fields of the current object. Also known as Reset.
func (e *CoreConfigData) Empty() *CoreConfigData { *e = CoreConfigData{}; return e }

// CoreConfigDataCollection represents a collection type for DB table core_config_data
// Not thread safe. Auto generated.
type CoreConfigDataCollection struct {
	Data             []*CoreConfigData                   `json:"data,omitempty"`
	BeforeMapColumns func(uint64, *CoreConfigData) error `json:"-"`
	AfterMapColumns  func(uint64, *CoreConfigData) error `json:"-"`
}

// NewCoreConfigDataCollection creates a new initialized collection. Auto generated.
func NewCoreConfigDataCollection() *CoreConfigDataCollection {
	return &CoreConfigDataCollection{
		Data: make([]*CoreConfigData, 0, 5),
	}
}

// AssignLastInsertID traverses through the slice and sets a decrementing new
// ID to each entity.
func (cc *CoreConfigDataCollection) AssignLastInsertID(id int64) {
	var j int64
	for i := len(cc.Data) - 1; i >= 0; i-- {
		cc.Data[i].AssignLastInsertID(id - j)
		j++
	}
}

func (cc *CoreConfigDataCollection) scanColumns(cm *dml.ColumnMap, e *CoreConfigData, idx uint64) error {
	if cc.BeforeMapColumns != nil {
		if err := cc.BeforeMapColumns(idx, e); err != nil {
			return errors.WithStack(err)
		}
	}
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	if cc.AfterMapColumns != nil {
		if err := cc.AfterMapColumns(idx, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CoreConfigDataCollection) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for i, e := range cc.Data {
			if err := cc.scanColumns(cm, e, uint64(i)); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		e := new(CoreConfigData)
		if err := cc.scanColumns(cm, e, cm.Count); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "config_id":
				cm = cm.Uint32s(cc.ConfigIDs()...)
			default:
				return errors.NotFound.Newf("[storage] CoreConfigDataCollection Column %q not found", c)
			}
		}
	default:
		return errors.NotSupported.Newf("[storage] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// ConfigIDs returns a slice or appends to a slice all values.
// Auto generated.
func (cc *CoreConfigDataCollection) ConfigIDs(ret ...uint32) []uint32 {
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ConfigID)
	}
	return ret
}

// Paths belongs to the column `path`
// and returns a slice or appends to a slice only unique values of that column.
// The values will be filtered internally in a Go map. No DB query gets
// executed. Auto generated.
func (cc *CoreConfigDataCollection) UniquePaths(ret ...string) []string {
	if ret == nil {
		ret = make([]string, 0, len(cc.Data))
	}

	dupCheck := make(map[string]bool, len(cc.Data))
	for _, e := range cc.Data {
		if !dupCheck[e.Path] {
			ret = append(ret, e.Path)
			dupCheck[e.Path] = true
		}
	}
	return ret
}
